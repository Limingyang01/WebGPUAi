<!DOCTYPE html>
<html lang="zh-CN" class="dark">
<head>
    <style>
        /* 防止主题闪烁的紧急样式 - 默认暗色 */
        html, body { background-color: #0a0a0a !important; }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>布丁离线AI助手</title>

    <link rel="icon" href="./favicon.ico">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <script>
        // 初始化主题类 - 立即执行，防止闪烁
        (function() {
            const savedTheme = localStorage.getItem('pudding_theme');
            const isDark = savedTheme === 'dark' || !savedTheme;

            if (!isDark) {
                // 亮色主题，移除 dark 类和紧急样式
                document.documentElement.classList.remove('dark');
                // 覆盖内联样式
                const style = document.querySelector('style');
                if (style && style.textContent.includes('background-color: #0a0a0a')) {
                    style.textContent = 'html, body { background-color: #ffffff !important; }';
                }
            }
            // 暗色主题保持默认样式（已在 HTML 中设置）
        })();
    </script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- WebLLM Module Loader -->
    <script type="module">
        // 预加载 WebLLM 模块
        window.loadWebLLM = async () => {
            const webllm = await import('https://esm.run/@mlc-ai/web-llm@0.2.79');
            return webllm;
        };
        console.log('WebLLM module loader ready');
    </script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #09090b;
            overflow-x: hidden;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #3f3f46;
            border-radius: 3px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #52525b;
        }

        .chat-message {
            white-space: pre-wrap;
            word-break: break-word;
            overflow-wrap: break-word;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .animate-spin {
            animation: spin 1s linear infinite;
        }

        .typing-dot {
            animation: typing 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {

            0%,
            60%,
            100% {
                transform: translateY(0);
            }

            30% {
                transform: translateY(-8px);
            }
        }
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOutDown {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-10px);
            }
        }

        .animate-fadeInUp {
            animation: fadeInUp 0.3s ease-out;
        }

        .animate-fadeOutDown {
            animation: fadeOutDown 0.3s ease-in;
        }

        /* 主题切换扩散动画 - 从图标位置开始 */
        .animate-theme-expand {
            animation: theme-expand 0.4s ease-out forwards;
        }

        @keyframes theme-expand {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 100vmax;
                height: 100vmax;
                opacity: 0;
            }
        }

        /* 亮色模式样式 */
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #ebebeb;
            --text-primary: #1f1f1f;
            --text-secondary: #525252;
            --text-tertiary: #737373;
            --border-color: #e5e5e5;
        }

        html.dark {
            --bg-primary: #0a0a0a;
            --bg-secondary: #18181b;
            --bg-tertiary: #1f1f23;
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --text-tertiary: #71717a;
            --border-color: #27272a;
        }

        /* 亮色模式下的表单控件 */
        html:not(.dark) .bg-\[\#1f1f23\] {
            background-color: #f5f5f5;
            border-color: #e5e5e5;
        }

        html:not(.dark) .bg-\[\#18181b\] {
            background-color: #ffffff;
            border-color: #e5e5e5;
        }

        html:not(.dark) .bg-\[\#27272a\] {
            background-color: #ebebeb;
            border-color: #d4d4d4;
        }

        html:not(.dark) .bg-\[\#0a0a0a\] {
            background-color: #ffffff;
        }

        html:not(.dark) .border-\[\#27272a\] {
            border-color: #e5e5e5;
        }

        html:not(.dark) .text-white {
            color: #1f1f1f;
        }

        html:not(.dark) .text-zinc-400 {
            color: #737373;
        }

        html:not(.dark) .text-zinc-500 {
            color: #525252;
        }
    </style>
</head>

<body>
    <!-- 启动遮罩层 - 防止白色闪烁 -->
    <div id="splash-screen" style="position:fixed;inset:0;background-color:#0a0a0a;z-index:9999;display:flex;align-items:center;justify-content:center;">
        <div style="text-align:center;">
            <div style="width:48px;height:48px;border-radius:12px;overflow:hidden;border:2px solid #f43f5e;box-shadow:0 10px 15px -3px rgba(244,63,94,0.3);">
                <img src="Ming.jpg" alt="Ming" style="width:100%;height:100%;object-fit:cover;" />
            </div>
            <p style="color:#71717a;font-size:14px;margin-top:16px;">加载中...</p>
        </div>
    </div>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        const { useState, useRef, useEffect, useCallback, useMemo } = React;

        // Icons
        const IconWrapper = ({ name, size = 24, className = "" }) => {
            const iconData = lucide.icons[name];
            if (!iconData) return null;
            return React.createElement('svg', {
                xmlns: "http://www.w3.org/2000/svg",
                width: size,
                height: size,
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: 2,
                strokeLinecap: "round",
                strokeLinejoin: "round",
                className: `lucide lucide-${name} ${className}`,
            }, ...iconData.map(([tag, attrs]) => React.createElement(tag, attrs)));
        };

        const BotIcon = (p) => <IconWrapper name="Bot" size={20} {...p} />;
        const UserIcon = (p) => <IconWrapper name="User" size={20} {...p} />;
        const Loader2 = (p) => <IconWrapper name="Loader2" size={20} {...p} />;
        const RefreshCw = (p) => <IconWrapper name="RefreshCw" size={16} {...p} />;
        const Send = (p) => <IconWrapper name="Send" size={18} {...p} />;
        const Check = (p) => <IconWrapper name="Check" size={16} {...p} />;
        const Database = (p) => <IconWrapper name="Database" size={16} {...p} />;
        const RefreshCcw = (p) => <IconWrapper name="RefreshCcw" size={16} {...p} />;
        const MonitorStop = (p) => <IconWrapper name="MonitorStop" size={18} {...p} />;
        const UserCircle = (p) => <IconWrapper name="UserCircle" size={16} {...p} />;
        const X = (p) => <IconWrapper name="X" size={18} {...p} />;
        const Copy = (p) => <IconWrapper name="Copy" size={14} {...p} />;
        const Trash2 = (p) => <IconWrapper name="Trash2" size={16} {...p} />;
        const Settings = (p) => <IconWrapper name="Settings" size={18} {...p} />;
        const MessageSquare = (p) => <IconWrapper name="MessageSquare" size={20} {...p} />;
        const Bot = (p) => <IconWrapper name="Bot" size={22} {...p} />;
        const Sun = (p) => <IconWrapper name="Sun" size={20} {...p} />;
        const Moon = (p) => <IconWrapper name="Moon" size={20} {...p} />;
        const Plus = (p) => <IconWrapper name="Plus" size={18} {...p} />;
        const CheckCircle = (p) => <IconWrapper name="CheckCircle" size={18} {...p} />;
        const Upload = (p) => <IconWrapper name="Upload" size={18} {...p} />;
        const FileText = (p) => <IconWrapper name="FileText" size={18} {...p} />;
        const BookOpen = (p) => <IconWrapper name="BookOpen" size={18} {...p} />;

        // ========== UI 组件 ==========

        // 角色选择下拉框
        const RoleSelect = ({ value, onChange, engine }) => {
            const handleChange = (e) => {
                onChange(e.target.value);
                if (engine) {
                    setMessages([]);
                    const roleInfo = ROLE_LIST.find(r => r.id === e.target.value);
                    const rolePrefix = e.target.value === 'default' ? '' : `【${roleInfo?.name || ''}】`;
                    setMessages([{
                        role: 'assistant',
                        content: `${rolePrefix}你好！我是${roleInfo?.name || 'AI助手'}。\n有什么可以帮你的吗？`,
                        timestamp: Date.now()
                    }]);
                }
            };
            return (
                <div className="relative">
                    <select
                        value={value}
                        onChange={handleChange}
                        className="appearance-none bg-gray-100 dark:bg-white/10 border border-gray-300 dark:border-white/20 rounded-full px-3 py-1 pr-8 text-xs text-gray-900 dark:text-white focus:outline-none focus:border-gray-400 dark:focus:border-white/40 cursor-pointer"
                    >
                        {ROLE_LIST.map(r => (
                            <option key={r.id} value={r.id} className="bg-white dark:bg-[#1f1f23] text-gray-900 dark:text-white">
                                {r.name}
                            </option>
                        ))}
                    </select>
                    <UserCircle className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-gray-500 dark:text-white/60" />
                </div>
            );
        };

        // 状态标签
        const StatusBadge = ({ status }) => (
            <span className={`text-xs px-2 py-1 rounded-full ${
                status === '已就绪' ? 'bg-emerald-100 dark:bg-emerald-500/20 text-emerald-700 dark:text-emerald-400' :
                    status === '错误' ? 'bg-red-100 dark:bg-red-500/20 text-red-700 dark:text-red-400' :
                        'bg-gray-200 dark:bg-white/10 text-gray-600 dark:text-white'
            }`}>
                {status}
            </span>
        );

        // 模型标签
        const ModelBadge = ({ name }) => (
            <span className="text-xs opacity-80 bg-gray-200 dark:bg-white/10 px-2 py-1 rounded-full text-gray-700 dark:text-white">
                {name}
            </span>
        );

        // 主按钮
        const PrimaryButton = ({ onClick, disabled, loading, children, engine }) => (
            <button
                onClick={onClick}
                disabled={disabled}
                className={`px-4 py-2 rounded-lg flex items-center gap-2 whitespace-nowrap transition-all ${loading
                    ? 'bg-zinc-600 disabled:opacity-50 cursor-not-allowed'
                    : engine
                        ? 'bg-emerald-600 hover:bg-emerald-500'
                        : 'bg-gradient-to-r from-violet-600 to-indigo-600'
                }`}
            >
                {loading ? (
                    <>
                        <Loader2 className="animate-spin" size={16} />
                        加载中
                    </>
                ) : engine ? (
                    <>
                        <RefreshCw size={16} />
                        重新加载
                    </>
                ) : (
                    <>
                        <Loader2 size={16} />
                        加载模型
                    </>
                )}
            </button>
        );

        // 发送按钮
        const SendButton = ({ onClick, disabled, loading }) => (
            <button
                onClick={onClick}
                disabled={disabled}
                className="px-4 py-2.5 bg-gradient-to-r from-violet-600 to-indigo-600 rounded-full disabled:opacity-50 disabled:cursor-not-allowed hover:opacity-90 transition-opacity flex items-center justify-center"
            >
                <Send />
            </button>
        );

        // 停止按钮
        const StopButton = ({ onClick }) => (
            <button
                onClick={onClick}
                className="px-4 py-2.5 bg-red-600 hover:bg-red-500 rounded-full transition-colors flex items-center justify-center"
            >
                <MonitorStop />
            </button>
        );

        // 消息气泡组件
        const MessageBubble = ({ role, content, timestamp, retrievedChunks }) => {
            // 检查 content 是否为 React 元素（JSX）
            const isReactElement = content && typeof content === 'object' && content.$$typeof;
            // 确保 content 是字符串，如果不是 React 元素则转换
            const safeContent = isReactElement ? '' : (typeof content === 'string' ? content : String(content || ''));
            const [copied, setCopied] = useState(false);
            const [thinkExpanded, setThinkExpanded] = useState(false);
            const [referencesExpanded, setReferencesExpanded] = useState(false);
            const isUser = role === 'user';
            const isAssistant = role === 'assistant';

            // 提取 think 内容
            const extractThinkContent = (text) => {
                // 如果不是字符串，直接返回
                if (!text || typeof text !== 'string') return { main: String(text || ''), think: '' };
                const startIdx = text.indexOf(THINK_START);
                const endIdx = text.indexOf(THINK_END);
                if (startIdx !== -1 && endIdx !== -1 && endIdx > startIdx) {
                    const think = text.substring(startIdx + THINK_START.length, endIdx).trim();
                    const main = (text.substring(0, startIdx) + text.substring(endIdx + THINK_END.length)).trim();
                    return { main, think };
                }
                return { main: text, think: '' };
            };

            const { main, think } = extractThinkContent(safeContent);
            const hasThink = !!think;

            const handleCopy = () => {
                const textToCopy = hasThink ? main : safeContent;
                if (typeof textToCopy === 'string') {
                    navigator.clipboard.writeText(textToCopy);
                    setCopied(true);
                    setTimeout(() => setCopied(false), 2000);
                }
            };

            return (
                <div className={`flex gap-3 ${isUser ? 'flex-row-reverse' : ''}`}>
                    <div className={`w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0 ${isUser ? 'bg-gradient-to-br from-violet-600 to-indigo-600' : 'bg-gray-200 dark:bg-[#27272a]'
                        }`}>
                        {isUser ? <UserIcon className={isUser ? '' : 'dark:text-white text-gray-700'} /> : <BotIcon className={isUser ? '' : 'dark:text-white text-gray-700'} />}
                    </div>
                    <div className={`max-w-[75%] ${isUser ? 'text-right' : ''}`}>
                        {/* Think 内容 - 浅色可折叠 */}
                        {hasThink && (
                            <div className="mb-2">
                                <button
                                    onClick={() => setThinkExpanded(!thinkExpanded)}
                                    className="flex items-center gap-1 text-xs text-gray-500 dark:text-zinc-500 hover:text-gray-700 dark:hover:text-zinc-400 transition-colors mb-1"
                                >
                                    {thinkExpanded ? (
                                        <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                        </svg>
                                    ) : (
                                        <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                                        </svg>
                                    )}
                                    <span>思考过程</span>
                                    <span className="text-gray-400 dark:text-zinc-600">({think.length} 字)</span>
                                </button>
                                {thinkExpanded && (
                                    <div className="text-xs text-gray-500 dark:text-zinc-500 bg-gray-100 dark:bg-[#1a1a1a] rounded-lg px-3 py-2 border border-gray-200 dark:border-zinc-800">
                                        <pre className="whitespace-pre-wrap font-mono">{think}</pre>
                                    </div>
                                )}
                            </div>
                        )}
                        <div className={`inline-block px-4 py-2.5 rounded-2xl text-sm chat-message ${isUser
                            ? 'bg-gradient-to-br from-violet-600 to-indigo-600 text-white rounded-tr-sm'
                            : 'bg-gray-100 dark:bg-[#27272a] text-gray-800 dark:text-zinc-200 rounded-tl-sm'
                            }`}>
                            {isUser ? safeContent : isReactElement ? content : (
                                hasThink ? <span dangerouslySetInnerHTML={{ __html: parseMarkdown(main) }} /> : <span dangerouslySetInnerHTML={{ __html: parseMarkdown(safeContent) }} />
                            )}
                        </div>
                        {/* 时间和复制按钮（仅AI消息） */}
                        <div className="flex items-center gap-3 mt-1 text-xs text-gray-400 dark:text-zinc-500">
                            <span>{timestamp ? formatTime(timestamp) : ''}</span>
                            {isAssistant && !isReactElement && (
                                <button
                                    onClick={handleCopy}
                                    className="flex items-center gap-1 hover:text-gray-600 dark:hover:text-zinc-300 transition-colors"
                                >
                                    {copied ? <Check className="text-emerald-400" /> : <Copy className="dark:text-zinc-500 text-gray-400" />}
                                </button>
                            )}
                        </div>
                        {/* 引用来源显示 */}
                        {isAssistant && !isReactElement && retrievedChunks && retrievedChunks.length > 0 && (
                            <div className="mt-2">
                                <button
                                    onClick={() => setReferencesExpanded(!referencesExpanded)}
                                    className="flex items-center gap-1 text-xs text-violet-500 hover:text-violet-400 transition-colors"
                                >
                                    {referencesExpanded ? (
                                        <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                        </svg>
                                    ) : (
                                        <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                                        </svg>
                                    )}
                                    <BookOpen size={12} />
                                    <span>参考资料 ({retrievedChunks.length})</span>
                                </button>
                                {referencesExpanded && (
                                    <div className="mt-2 space-y-2">
                                        {retrievedChunks.map((chunk, i) => (
                                            <div key={i} className="text-xs bg-gray-50 dark:bg-[#1f1f23] rounded-lg p-2 border border-gray-200 dark:border-[#27272a]">
                                                <div className="font-medium text-violet-500 mb-1">来源 {i + 1}{chunk.sourceName ? ` - ${chunk.sourceName}` : ''}</div>
                                                <div className="text-gray-600 dark:text-zinc-400 line-clamp-3">{chunk.content}</div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // ========== 全局消息组件 (类似 antd Message) ==========

        // Message Context
        const MessageContext = React.createContext(null);

        // Message Provider 组件
        const MessageProvider = ({ children }) => {
            const [messages, setMessages] = useState([]);

            // 添加消息
            const addMessage = useCallback((content, type = 'info', duration = 3000) => {
                const id = Date.now() + Math.random();
                const message = { id, content, type, duration };

                setMessages(prev => [...prev, message]);

                // 自动移除
                if (duration > 0) {
                    setTimeout(() => {
                        removeMessage(id);
                    }, duration);
                }

                return id;
            }, []);

            // 移除消息
            const removeMessage = useCallback((id) => {
                setMessages(prev => prev.filter(msg => msg.id !== id));
            }, []);

            // 便捷方法
            const success = useCallback((content, duration) => addMessage(content, 'success', duration), [addMessage]);
            const error = useCallback((content, duration) => addMessage(content, 'error', duration), [addMessage]);
            const warning = useCallback((content, duration) => addMessage(content, 'warning', duration), [addMessage]);
            const info = useCallback((content, duration) => addMessage(content, 'info', duration), [addMessage]);

            const value = { success, error, warning, info, addMessage, removeMessage };

            return (
                <MessageContext.Provider value={value}>
                    {children}
                    <div className="fixed top-4 left-1/2 -translate-x-1/2 z-[100] flex flex-col gap-2 pointer-events-none">
                        {messages.map(msg => (
                            <MessageItem
                                key={msg.id}
                                message={msg}
                                onClose={() => removeMessage(msg.id)}
                            />
                        ))}
                    </div>
                </MessageContext.Provider>
            );
        };

        // 单个消息项
        const MessageItem = ({ message, onClose }) => {
            const { type, content } = message;

            const icons = {
                success: (
                    <svg className="w-5 h-5 text-emerald-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" strokeLinecap="round" strokeLinejoin="round"/>
                        <path d="M22 4L12 14.01l-3-3" strokeLinecap="round" strokeLinejoin="round"/>
                    </svg>
                ),
                error: (
                    <svg className="w-5 h-5 text-red-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="15" y1="9" x2="9" y2="15"/>
                        <line x1="9" y1="9" x2="15" y2="15"/>
                    </svg>
                ),
                warning: (
                    <svg className="w-5 h-5 text-amber-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                        <line x1="12" y1="9" x2="12" y2="13"/>
                        <line x1="12" y1="17" x2="12.01" y2="17"/>
                    </svg>
                ),
                info: (
                    <svg className="w-5 h-5 text-blue-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="16" x2="12" y2="12"/>
                        <line x1="12" y1="8" x2="12.01" y2="8"/>
                    </svg>
                )
            };

            const bgColors = {
                success: 'bg-emerald-500/10 border-emerald-500/30',
                error: 'bg-red-500/10 border-red-500/30',
                warning: 'bg-amber-500/10 border-amber-500/30',
                info: 'bg-blue-500/10 border-blue-500/30'
            };

            return (
                <div
                    className={`animate-fadeInUp pointer-events-auto flex items-center gap-3 px-4 py-3 rounded-lg border ${bgColors[type]} shadow-lg max-w-sm`}
                >
                    {icons[type]}
                    <span className="text-sm text-white flex-1">{content}</span>
                    <button
                        onClick={onClose}
                        className="text-zinc-400 hover:text-white transition-colors"
                    >
                        <X size={14} />
                    </button>
                </div>
            );
        };

        // Hook 获取 message 方法
        const useMessage = () => {
            const context = React.useContext(MessageContext);
            if (!context) {
                console.warn('useMessage 必须在 MessageProvider 内使用');
                return {
                    success: () => {},
                    error: () => {},
                    warning: () => {},
                    info: () => {}
                };
            }
            return context;
        };

        // ========== 确认弹框组件 ==========

        // Confirm Context
        const ConfirmContext = React.createContext(null);

        // Confirm Provider（在 MessageProvider 内部使用）
        const ConfirmProvider = ({ children }) => {
            const [confirmData, setConfirmData] = useState(null);

            const showConfirm = useCallback((options) => {
                return new Promise((resolve) => {
                    const handleConfirm = () => {
                        setConfirmData(null);
                        resolve(true);
                    };
                    const handleCancel = () => {
                        setConfirmData(null);
                        resolve(false);
                    };
                    setConfirmData({
                        open: true,
                        title: options.title || '确认操作',
                        content: options.content || '确定要执行此操作吗？',
                        confirmText: options.confirmText || '确定',
                        cancelText: options.cancelText || '取消',
                        type: options.type || 'danger',
                        onConfirm: handleConfirm,
                        onCancel: handleCancel
                    });
                });
            }, []);

            const hideConfirm = useCallback(() => {
                setConfirmData(null);
            }, []);

            const value = { showConfirm, hideConfirm };

            return (
                <ConfirmContext.Provider value={value}>
                    {children}
                    {confirmData && (
                        <ConfirmDialog
                            open={confirmData.open}
                            title={confirmData.title}
                            content={confirmData.content}
                            confirmText={confirmData.confirmText}
                            cancelText={confirmData.cancelText}
                            type={confirmData.type}
                            onConfirm={confirmData.onConfirm}
                            onCancel={confirmData.onCancel}
                        />
                    )}
                </ConfirmContext.Provider>
            );
        };

        // 确认弹框组件
        const ConfirmDialog = ({ open, title, content, confirmText, cancelText, type, onConfirm, onCancel }) => {
            if (!open) return null;

            const typeConfig = {
                danger: {
                    icon: (
                        <svg className="w-12 h-12 text-red-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="15" y1="9" x2="9" y2="15"/>
                            <line x1="9" y1="9" x2="15" y2="15"/>
                        </svg>
                    ),
                    confirmBtn: 'bg-red-600 hover:bg-red-500',
                },
                warning: {
                    icon: (
                        <svg className="w-12 h-12 text-amber-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                            <line x1="12" y1="9" x2="12" y2="13"/>
                            <line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                    ),
                    confirmBtn: 'bg-amber-600 hover:bg-amber-500',
                },
                info: {
                    icon: (
                        <svg className="w-12 h-12 text-blue-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="16" x2="12" y2="12"/>
                            <line x1="12" y1="8" x2="12.01" y2="8"/>
                        </svg>
                    ),
                    confirmBtn: 'bg-blue-600 hover:bg-blue-500',
                },
            };

            const config = typeConfig[type] || typeConfig.info;

            return (
                <div className="fixed inset-0 z-[200] flex items-center justify-center">
                    <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" onClick={onCancel} />
                    <div className="relative bg-[#18181b] rounded-2xl shadow-2xl max-w-sm w-full mx-4 p-6 animate-fadeInUp">
                        <div className="flex justify-center mb-4">{config.icon}</div>
                        <h3 className="text-lg font-semibold text-white text-center mb-2">{title}</h3>
                        <p className="text-sm text-zinc-400 text-center mb-6">{content}</p>
                        <div className="flex gap-3">
                            <button onClick={onCancel} className="flex-1 px-4 py-2.5 bg-[#3f3f46] hover:bg-[#52525b] text-white rounded-xl transition-colors">
                                {cancelText}
                            </button>
                            <button onClick={onConfirm} className={`flex-1 px-4 py-2.5 ${config.confirmBtn} text-white rounded-xl transition-colors`}>
                                {confirmText}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Hook 获取 confirm 方法
        const useConfirm = () => {
            const context = React.useContext(ConfirmContext);
            if (!context) {
                console.warn('useConfirm 必须在 ConfirmProvider 内使用');
                return { showConfirm: async () => false, hideConfirm: () => {} };
            }
            return context;
        };

        // ========== 组件结束 ==========

        // 模型列表
        const MODEL_LIST = [
            // 低显存模型 (<=2GB)
            { id: 'Qwen2.5-0.5B-Instruct-q4f32_1-MLC', name: 'Qwen2.5-0.5B', desc: '中文，0.5B参数', category: 'low' },
            { id: 'Qwen2-1.5B-Instruct-q4f32_1-MLC', name: 'Qwen2-1.5B', desc: '中文，1.5B参数', category: 'low' },
            { id: 'Qwen2.5-3B-Instruct-q4f32_1-MLC', name: 'Qwen2.5-3B', desc: '中文，3B参数', category: 'high' },
            { id: 'Phi-3.5-mini-instruct-q4f32_1-MLC', name: 'Phi-3.5-mini', desc: '约2GB显存', category: 'high' },
            // 高显存模型 (>2GB)
            { id: 'Qwen3-4B-q4f16_1-MLC', name: 'Qwen3-4B', desc: '中文最新，4B参数，推荐', category: 'high' },
        ];

        // 角色提示词
        const ROLE_LIST = [
            { id: 'default', name: '通用助手', systemPrompt: '你是一个友好的AI助手，请用简洁清晰的语言回答用户的问题。' },
            { id: 'poet', name: '诗词助手', systemPrompt: '你是一个诗词专家，精通中国古典诗词和现代诗歌。用户向你请教诗词创作、赏析、格律方面的问题时，你应该：1. 分析诗词的意境、韵律、手法 2. 提供创作建议和修改意见 3. 引用相关诗句作为例证 4. 用优美而有诗意的语言表达' },
            { id: 'writer', name: '写作助手', systemPrompt: '你是一个专业写作导师，擅长各种文体的写作指导。用户向你请教写作问题时，你应该：1. 分析文章结构和写作技巧 2. 提供具体的改进建议 3. 给出写作范例 4. 鼓励用户创作，帮助提升文笔' },
            { id: 'medical', name: '医护助手', systemPrompt: '你是一个医护健康顾问，主要提供健康知识科普和日常护理建议。注意：1. 强调仅为参考，不能替代医生诊断 2. 建议用户有健康问题及时就医 3. 提供科学可靠的健康知识 4. 用温和关怀的语气交流' },
            { id: 'emotional', name: '情感陪护', systemPrompt: '你是一个温暖贴心的情感陪伴者。用户向你倾诉情感困惑时，你应该：1. 认真倾听，给予理解和共情 2. 提供真诚的建议和观点 3. 用温柔治愈的语气交流 4. 适当给予鼓励和支持 5. 保护用户隐私' },
        ];

        // Think 标签边界字符（用于解析 AI 输出的思考内容）
        const THINK_START = '<think>';
        const THINK_END = '</think>';

        // 简单的 Markdown 解析函数
        const parseMarkdown = (text) => {
            if (!text) return '';
            if (typeof text !== 'string') return String(text);

            // 先处理代码块（避免其他转换影响代码块内的内容）
            let html = text;

            // 代码块 ```code``` 或 ```语言\ncode```
            html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                return `<pre class="bg-[#1a1a1a] rounded-lg p-3 my-2 overflow-x-auto text-xs font-mono border border-zinc-700"><code>${code.trim()}</code></pre>`;
            });

            // 第一步：先处理 HTML 实体转义（将 &lt; 转换为 < 等），以便后续正则能匹配
            html = html.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');

            // 处理 AI 直接输出的原始 <pre><code> 标签（保留样式，不转义）
            // 匹配 <pre ...><code>...</code></pre> 格式，支持任意属性
            html = html.replace(/<pre[^>]*><code>([\s\S]*?)<\/code><\/pre>/gi, (match, code) => {
                return `<pre class="bg-[#1a1a1a] rounded-lg p-3 my-2 overflow-x-auto text-xs font-mono border border-zinc-700"><code>${code.trim()}</code></pre>`;
            });

            // 处理 <pre><code>...</code></pre> 无属性版本
            html = html.replace(/<pre><code>([\s\S]*?)<\/code><\/pre>/gi, (match, code) => {
                return `<pre class="bg-[#1a1a1a] rounded-lg p-3 my-2 overflow-x-auto text-xs font-mono border border-zinc-700"><code>${code.trim()}</code></pre>`;
            });

            // 处理原始 <pre>...</pre> 标签（无 code 包装）
            html = html.replace(/<pre[^>]*>([\s\S]*?)<\/pre>/gi, (match, code) => {
                return `<pre class="bg-[#1a1a1a] rounded-lg p-3 my-2 overflow-x-auto text-xs font-mono border border-zinc-700"><code>${code.trim()}</code></pre>`;
            });

            // 处理原始 <code> 标签（行内）- 贪婪匹配
            html = html.replace(/<code>([\s\S]*?)<\/code>/gi, '<code class="bg-[#1a1a1a] px-1.5 py-0.5 rounded text-xs font-mono text-pink-400">$1</code>');

            // 转义 HTML 特殊字符（在代码块处理之后）
            html = html
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            // 行内代码 `code` - 支持包含空格的代码
            html = html.replace(/`([^`\n]+)`/g, '<code class="bg-[#1a1a1a] px-1.5 py-0.5 rounded text-xs font-mono text-pink-400">$1</code>');

            // 标题 #### Title (h4)
            html = html.replace(/^#### (.+)$/gm, '<h4 class="text-sm font-semibold text-white mt-3 mb-2">$1</h4>');
            // 标题 ### Title
            html = html.replace(/^### (.+)$/gm, '<h3 class="text-base font-semibold text-white mt-3 mb-2">$1</h3>');
            // 标题 ## Title
            html = html.replace(/^## (.+)$/gm, '<h2 class="text-lg font-semibold text-white mt-4 mb-2">$1</h2>');
            // 标题 # Title
            html = html.replace(/^# (.+)$/gm, '<h1 class="text-xl font-bold text-white mt-4 mb-2">$1</h1>');

            // 粗体 **text** 或 __text__
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong class="font-bold text-white">$1</strong>');
            html = html.replace(/__([^_]+)__/g, '<strong class="font-bold text-white">$1</strong>');

            // 斜体 *text* 或 _text_
            html = html.replace(/(?<!\*)\*(?!\*)([^*\n]+)(?<!\*)\*(?!\*)/g, '<em>$1</em>');
            html = html.replace(/(?<!_)_([^_\n]+)_(?!_)/g, '<em>$1</em>');

            // 删除线 ~~text~~
            html = html.replace(/~~([^~]+)~~/g, '<del class="line-through text-zinc-500">$1</del>');

            // 无序列表 - item
            html = html.replace(/^- (.+)$/gm, '<li class="ml-4 text-zinc-300">$1</li>');
            // 无序列表 * item
            html = html.replace(/^\* (.+)$/gm, '<li class="ml-4 text-zinc-300">$1</li>');
            // 无序列表 + item
            html = html.replace(/^\+ (.+)$/gm, '<li class="ml-4 text-zinc-300">$1</li>');

            // 有序列表 1. item
            html = html.replace(/^\d+\. (.+)$/gm, '<li class="ml-4 text-zinc-300 list-decimal">$1</li>');

            // 链接 [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" class="text-violet-400 hover:underline">$1</a>');

            // 引用 > quote
            html = html.replace(/^&gt; (.+)$/gm, '<blockquote class="border-l-4 border-violet-500 pl-3 italic text-zinc-400 my-2">$1</blockquote>');

            // 水平线 --- 或 *** 或 ___
            html = html.replace(/^---$/gm, '<hr class="border-zinc-700 my-4">');
            html = html.replace(/^\*\*\*$/gm, '<hr class="border-zinc-700 my-4">');
            html = html.replace(/^___$/gm, '<hr class="border-zinc-700 my-4">');

            // 换行处理 - 确保段落之间有间距
            html = html.replace(/\n\n/g, '</p><p class="my-2">');
            // 处理单换行
            html = html.replace(/\n/g, '<br>');

            // 包裹在段落标签中（如果没有以 HTML 标签开头）
            if (!html.startsWith('<')) {
                html = '<p class="my-2">' + html + '</p>';
            }

            return html;
        };

        // 时间格式化（显示到秒）
        const formatTime = (timestamp) => {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        };

        // ========== IndexedDB 历史记录模块 ==========
        const ConversationDB = {
            dbName: 'pudding-chat-db',
            storeName: 'conversations',
            version: 1,

            // 打开数据库
            open() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            db.createObjectStore(this.storeName, { keyPath: 'id', autoIncrement: true });
                        }
                    };
                });
            },

            // 创建对话
            async create(conversation) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const now = Date.now();
                    const data = {
                        ...conversation,
                        createdAt: now,
                        updatedAt: now,
                    };
                    const request = store.add(data);
                    request.onsuccess = () => resolve({ ...data, id: request.result });
                    request.onerror = () => reject(request.error);
                });
            },

            // 获取单个对话
            async get(id) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.get(id);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },

            // 获取所有对话（按更新时间倒序）
            async getAll() {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.getAll();
                    request.onsuccess = () => {
                        const conversations = request.result || [];
                        conversations.sort((a, b) => b.updatedAt - a.updatedAt);
                        resolve(conversations);
                    };
                    request.onerror = () => reject(request.error);
                });
            },

            // 更新对话
            async update(id, data) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const getRequest = store.get(id);
                    getRequest.onsuccess = () => {
                        const existing = getRequest.result || {};
                        const updated = { ...existing, ...data, updatedAt: Date.now() };
                        const putRequest = store.put(updated);
                        putRequest.onsuccess = () => resolve(updated);
                        putRequest.onerror = () => reject(putRequest.error);
                    };
                    getRequest.onerror = () => reject(getRequest.error);
                });
            },

            // 删除对话
            async delete(id) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },

            // 获取对话数量
            async count() {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.count();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },
        };

        // ========== 知识库 IndexedDB 模块 ==========
        const KnowledgeDB = {
            dbName: 'pudding-knowledge-db',
            version: 1,

            open() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        // 知识库存储
                        if (!db.objectStoreNames.contains('knowledgeBases')) {
                            const kbStore = db.createObjectStore('knowledgeBases', { keyPath: 'id', autoIncrement: true });
                            kbStore.createIndex('name', 'name', { unique: false });
                        }
                        // 文档存储
                        if (!db.objectStoreNames.contains('documents')) {
                            const docStore = db.createObjectStore('documents', { keyPath: 'id', autoIncrement: true });
                            docStore.createIndex('knowledgeBaseId', 'knowledgeBaseId', { unique: false });
                        }
                        // 文本块存储
                        if (!db.objectStoreNames.contains('chunks')) {
                            const chunkStore = db.createObjectStore('chunks', { keyPath: 'id', autoIncrement: true });
                            chunkStore.createIndex('documentId', 'documentId', { unique: false });
                            chunkStore.createIndex('content', 'content', { unique: false });
                        }
                    };
                });
            },

            // 知识库 CRUD
            async createKnowledgeBase(data) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['knowledgeBases'], 'readwrite');
                    const store = transaction.objectStore('knowledgeBases');
                    const now = Date.now();
                    const kbData = {
                        name: data.name || '未命名知识库',
                        description: data.description || '',
                        documentCount: 0,
                        createdAt: now,
                        updatedAt: now,
                    };
                    const request = store.add(kbData);
                    request.onsuccess = () => resolve({ ...kbData, id: request.result });
                    request.onerror = () => reject(request.error);
                });
            },

            async getAllKnowledgeBases() {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['knowledgeBases'], 'readonly');
                    const store = transaction.objectStore('knowledgeBases');
                    const request = store.getAll();
                    request.onsuccess = () => {
                        const kbs = request.result || [];
                        kbs.sort((a, b) => b.updatedAt - a.updatedAt);
                        resolve(kbs);
                    };
                    request.onerror = () => reject(request.error);
                });
            },

            async getKnowledgeBase(id) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['knowledgeBases'], 'readonly');
                    const store = transaction.objectStore('knowledgeBases');
                    const request = store.get(id);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },

            async updateKnowledgeBase(id, data) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['knowledgeBases'], 'readwrite');
                    const store = transaction.objectStore('knowledgeBases');
                    const getRequest = store.get(id);
                    getRequest.onsuccess = () => {
                        const existing = getRequest.result || {};
                        const updated = { ...existing, ...data, updatedAt: Date.now() };
                        const putRequest = store.put(updated);
                        putRequest.onsuccess = () => resolve(updated);
                        putRequest.onerror = () => reject(putRequest.error);
                    };
                    getRequest.onerror = () => reject(getRequest.error);
                });
            },

            async deleteKnowledgeBase(id) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    // 删除知识库
                    const transaction = db.transaction(['knowledgeBases', 'documents', 'chunks'], 'readwrite');
                    const kbStore = transaction.objectStore('knowledgeBases');
                    kbStore.delete(id);

                    // 删除相关文档
                    const docStore = transaction.objectStore('documents');
                    const docIndex = docStore.index('knowledgeBaseId');
                    const docRequest = docIndex.getAllKeys(id);
                    docRequest.onsuccess = () => {
                        const docKeys = docRequest.result;
                        docKeys.forEach(key => docStore.delete(key));

                        // 删除相关文本块
                        const chunkStore = transaction.objectStore('chunks');
                        docKeys.forEach(docId => {
                            const chunkIndex = chunkStore.index('documentId');
                            const chunkRequest = chunkIndex.getAllKeys(docId);
                            chunkRequest.onsuccess = () => {
                                chunkRequest.result.forEach(key => chunkStore.delete(key));
                            };
                        });
                    };

                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            },

            // 文档 CRUD
            async addDocument(data) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['documents', 'knowledgeBases'], 'readwrite');
                    const store = transaction.objectStore('documents');
                    const now = Date.now();
                    const docData = {
                        knowledgeBaseId: data.knowledgeBaseId,
                        name: data.name,
                        type: data.type,
                        content: data.content,
                        chunkCount: data.chunkCount || 0,
                        status: data.status || 'pending',
                        createdAt: now,
                    };
                    const request = store.add(docData);

                    // 更新知识库文档计数
                    transaction.oncomplete = async () => {
                        const kb = await this.getKnowledgeBase(data.knowledgeBaseId);
                        if (kb) {
                            await this.updateKnowledgeBase(data.knowledgeBaseId, {
                                documentCount: (kb.documentCount || 0) + 1
                            });
                        }
                    };

                    request.onsuccess = () => resolve({ ...docData, id: request.result });
                    request.onerror = () => reject(request.error);
                });
            },

            async getDocumentsByKnowledgeBase(knowledgeBaseId) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['documents'], 'readonly');
                    const store = transaction.objectStore('documents');
                    const index = store.index('knowledgeBaseId');
                    const request = index.getAll(knowledgeBaseId);
                    request.onsuccess = () => {
                        const docs = request.result || [];
                        docs.sort((a, b) => b.createdAt - a.createdAt);
                        resolve(docs);
                    };
                    request.onerror = () => reject(request.error);
                });
            },

            async deleteDocument(id) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['documents', 'chunks', 'knowledgeBases'], 'readwrite');

                    // 获取文档信息
                    const docStore = transaction.objectStore('documents');
                    const getRequest = docStore.get(id);
                    getRequest.onsuccess = async () => {
                        const doc = getRequest.result;
                        if (!doc) {
                            resolve();
                            return;
                        }

                        // 删除文档
                        docStore.delete(id);

                        // 删除相关文本块
                        const chunkStore = transaction.objectStore('chunks');
                        const chunkIndex = chunkStore.index('documentId');
                        const chunkRequest = chunkIndex.getAllKeys(id);
                        chunkRequest.onsuccess = () => {
                            chunkRequest.result.forEach(key => chunkStore.delete(key));
                        };

                        // 更新知识库计数
                        const kbStore = transaction.objectStore('knowledgeBases');
                        const kbGet = kbStore.get(doc.knowledgeBaseId);
                        kbGet.onsuccess = () => {
                            const kb = kbGet.result;
                            if (kb) {
                                kb.documentCount = Math.max(0, (kb.documentCount || 1) - 1);
                                kbStore.put(kb);
                            }
                        };
                    };

                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            },

            // 文本块 CRUD
            async addChunks(documentId, chunks) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['chunks'], 'readwrite');
                    const store = transaction.objectStore('chunks');
                    const now = Date.now();

                    chunks.forEach((content, index) => {
                        store.add({
                            documentId,
                            content,
                            index,
                            createdAt: now,
                        });
                    });

                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            },

            async getChunksByDocument(documentId) {
                const db = await this.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['chunks'], 'readonly');
                    const store = transaction.objectStore('chunks');
                    const index = store.index('documentId');
                    const request = index.getAll(documentId);
                    request.onsuccess = () => {
                        const chunks = request.result || [];
                        chunks.sort((a, b) => a.index - b.index);
                        resolve(chunks);
                    };
                    request.onerror = () => reject(request.error);
                });
            },

            async getAllChunks(knowledgeBaseId) {
                const db = await this.open();
                return new Promise(async (resolve, reject) => {
                    // 获取该知识库下所有文档
                    const docs = await this.getDocumentsByKnowledgeBase(knowledgeBaseId);
                    const docIds = docs.map(d => d.id);

                    const db2 = await this.open();
                    const transaction = db2.transaction(['chunks'], 'readonly');
                    const store = transaction.objectStore('chunks');
                    const request = store.getAll();
                    request.onsuccess = () => {
                        const allChunks = request.result || [];
                        // 过滤出属于该知识库的文本块
                        const filtered = allChunks.filter(c => docIds.includes(c.documentId));
                        resolve(filtered);
                    };
                    request.onerror = () => reject(request.error);
                });
            },
        };

        // ========== 文本分块工具 ==========
        const chunkText = (text, chunkSize = 500, overlap = 50) => {
            if (!text || text.trim().length === 0) return [];

            const chunks = [];
            let start = 0;
            const textLength = text.length;

            while (start < textLength) {
                let end = start + chunkSize;

                // 尽量在句子边界分割
                if (end < textLength) {
                    const periodIndex = text.indexOf('。', end - 50);
                    const commaIndex = text.indexOf('，', end - 50);
                    const newlineIndex = text.indexOf('\n', end - 50);

                    const boundaryIndices = [periodIndex, commaIndex, newlineIndex].filter(i => i > end - 150 && i < end + 50);
                    if (boundaryIndices.length > 0) {
                        end = Math.min(...boundaryIndices) + 1;
                    }
                }

                const chunk = text.slice(start, end).trim();
                if (chunk.length > 0) {
                    chunks.push(chunk);
                }

                start = end - overlap;
                if (start >= textLength) break;
            }

            return chunks;
        };

        // ========== 检索工具（改进的中文关键词检索） ==========
        const searchChunks = (chunks, query, topK = 5) => {
            if (!query || chunks.length === 0) return [];

            // 判断是否为中文
            const isChinese = /[\u4e00-\u9fa5]/.test(query);
            let queryWords = [];

            if (isChinese) {
                // 中文：提取所有 2-4 个字符的组合作为关键词
                const cleanedQuery = query.replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, '').toLowerCase();
                // 生成 2-4 字的滑动窗口
                for (let len = 2; len <= 4; len++) {
                    for (let i = 0; i <= cleanedQuery.length - len; i++) {
                        const word = cleanedQuery.slice(i, i + len);
                        if (word.length === len) {
                            queryWords.push(word);
                        }
                    }
                }
            } else {
                // 英文：使用空格分割
                queryWords = query.toLowerCase().split(/\s+/).filter(w => w.length > 1);
            }

            const queryLower = query.toLowerCase();

            const scoredChunks = chunks.map(chunk => {
                const contentLower = chunk.content.toLowerCase();
                let score = 0;
                let matchCount = 0;

                // 1. 精确匹配整个查询（最高优先级）
                if (contentLower.includes(queryLower)) {
                    score += 20;
                }

                // 2. 关键词匹配
                queryWords.forEach(word => {
                    if (contentLower.includes(word)) {
                        score += 5;
                        const matches = contentLower.split(word).length - 1;
                        score += matches * 2;
                        matchCount++;
                    }
                });

                // 3. 短关键词匹配奖励（更灵活）
                if (isChinese) {
                    // 中文：检查是否包含查询中的任意字符
                    const queryChars = query.replace(/[^\u4e00-\u9fa5]/g, '').split('');
                    const matchedChars = queryChars.filter(c => contentLower.includes(c));
                    if (matchedChars.length > 0) {
                        score += matchedChars.length * 0.5;
                    }
                }

                // 4. 位置奖励（查询词出现在开头）
                const firstMatchIndex = contentLower.indexOf(queryWords[0] || queryLower);
                if (firstMatchIndex !== -1 && firstMatchIndex < 50) {
                    score += 3;
                }

                // 5. 长度惩罚（避免过长文本）
                if (chunk.content.length > 1000) {
                    score = score * 0.8;
                }

                return { ...chunk, score, matchCount };
            });

            // 过滤：至少要有匹配
            return scoredChunks
                .filter(c => c.score > 0 || c.matchCount > 0)
                .sort((a, b) => {
                    // 优先按匹配数量，再按分数
                    if (b.matchCount !== a.matchCount) {
                        return b.matchCount - a.matchCount;
                    }
                    return b.score - a.score;
                })
                .slice(0, topK);
        };

        // 构建 RAG Prompt
        const buildRAGPrompt = (query, retrievedChunks, systemPrompt = '') => {
            const context = retrievedChunks
                .map((chunk, i) => `[来源${i + 1}${chunk.sourceName ? ` - ${chunk.sourceName}` : ''}]: ${chunk.content}`)
                .join('\n\n');

            const ragPrompt = `你是一个基于知识库问答的AI助手。请根据以下参考资料回答用户的问题。

参考资料：
${context}

用户问题：${query}

请根据参考资料回答，如果参考资料中没有相关信息，请如实说明你无法根据已知信息回答这个问题，并给出合理的建议。`;

            return ragPrompt;
        };

        // ========== 历史记录组件 ==========

        // 历史记录抽屉
        const HistoryDrawer = ({ open, onClose, conversations, onLoadConversation, onNewChat, onDeleteConversation }) => {
            const [groupedConversations, setGroupedConversations] = useState({ today: [], yesterday: [], earlier: [] });

            useEffect(() => {
                if (conversations.length > 0) {
                    const now = Date.now();
                    const oneDay = 24 * 60 * 60 * 1000;
                    const todayStart = new Date().setHours(0, 0, 0, 0);
                    const yesterdayStart = todayStart - oneDay;

                    const grouped = { today: [], yesterday: [], earlier: [] };
                    conversations.forEach(conv => {
                        if (conv.updatedAt >= todayStart) {
                            grouped.today.push(conv);
                        } else if (conv.updatedAt >= yesterdayStart) {
                            grouped.yesterday.push(conv);
                        } else {
                            grouped.earlier.push(conv);
                        }
                    });
                    setGroupedConversations(grouped);
                } else {
                    setGroupedConversations({ today: [], yesterday: [], earlier: [] });
                }
            }, [conversations]);

            const formatConversationTime = (timestamp) => {
                const date = new Date(timestamp);
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${hours}:${minutes}`;
            };

            const renderGroup = (title, list) => {
                if (list.length === 0) return null;
                return (
                    <div className="mb-4">
                        <div className="text-xs text-gray-500 dark:text-zinc-500 px-3 mb-2">{title}</div>
                        {list.map(conv => (
                            <div
                                key={conv.id}
                                className="group flex items-center justify-between px-3 py-2 hover:bg-gray-100 dark:hover:bg-[#27272a] cursor-pointer transition-colors"
                                onClick={() => onLoadConversation(conv)}
                            >
                                <div className="flex-1 min-w-0">
                                    <div className="text-sm text-gray-900 dark:text-white truncate">{conv.title || '新对话'}</div>
                                    <div className="text-xs text-gray-500 dark:text-zinc-500">{formatConversationTime(conv.updatedAt)}</div>
                                </div>
                                <button
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onDeleteConversation(conv.id);
                                    }}
                                    className="opacity-0 group-hover:opacity-100 p-1 hover:bg-gray-200 dark:hover:bg-[#3f3f46] rounded transition-all"
                                >
                                    <X size={14} className="text-gray-500 dark:text-zinc-400" />
                                </button>
                            </div>
                        ))}
                    </div>
                );
            };

            if (!open) return null;

            return (
                <>
                    {/* 遮罩层 */}
                    <div
                        className="fixed inset-0 bg-black/50 z-40"
                        onClick={onClose}
                    />
                    {/* 抽屉 */}
                    <div className="fixed left-0 top-0 bottom-0 w-72 bg-white dark:bg-[#18181b] z-50 border-r border-gray-200 dark:border-[#27272a] flex flex-col transform transition-transform duration-300">
                        {/* 头部 */}
                        <div className="p-4 border-b border-gray-200 dark:border-[#27272a] flex items-center justify-between">
                            <h2 className="text-lg font-semibold text-gray-900 dark:text-white">历史记录</h2>
                            <button
                                onClick={onNewChat}
                                className="px-3 py-1.5 bg-violet-600 hover:bg-violet-500 rounded-lg text-sm text-white flex items-center gap-1.5 transition-colors"
                            >
                                <RefreshCw size={14} />
                                新建对话
                            </button>
                        </div>
                        {/* 列表 */}
                        <div className="flex-1 overflow-y-auto custom-scrollbar">
                            {conversations.length === 0 ? (
                                <div className="text-center text-gray-500 dark:text-zinc-500 py-8 text-sm">
                                    暂无历史记录
                                </div>
                            ) : (
                                <>
                                    {renderGroup('今天', groupedConversations.today)}
                                    {renderGroup('昨天', groupedConversations.yesterday)}
                                    {renderGroup('更早', groupedConversations.earlier)}
                                </>
                            )}
                        </div>
                    </div>
                </>
            );
        };

        // ========== 模型管理组件 ==========
        const ModelManager = ({ open, onClose, cachedModels, onRefreshModels, onDeleteModel, onClearAll }) => {
            const [syncing, setSyncing] = useState(false);
            const { success, info } = useMessage();

            const formatModelSize = (sizeInBytes) => {
                if (!sizeInBytes) return '未知大小';
                const gb = sizeInBytes / (1024 * 1024 * 1024);
                if (gb >= 1) return `${gb.toFixed(2)} GB`;
                const mb = sizeInBytes / (1024 * 1024);
                return `${mb.toFixed(0)} MB`;
            };

            const handleRefresh = async () => {
                setSyncing(true);
                info('正在同步模型缓存...');
                await onRefreshModels();
                setSyncing(false);
                success('同步完成');
            };

            if (!open) return null;

            return (
                <>
                    {/* 遮罩层 */}
                    <div
                        className="fixed inset-0 bg-black/50 z-40"
                        onClick={onClose}
                    />
                    {/* 面板 */}
                    <div className="fixed right-0 top-0 bottom-0 w-80 bg-white dark:bg-[#18181b] z-50 border-l border-gray-200 dark:border-[#27272a] flex flex-col transform transition-transform duration-300">
                        {/* 头部 */}
                        <div className="p-4 border-b border-gray-200 dark:border-[#27272a] flex items-center justify-between">
                            <h2 className="text-lg font-semibold text-gray-900 dark:text-white">模型管理</h2>
                            <button
                                onClick={onClose}
                                className="p-1 hover:bg-gray-100 dark:hover:bg-[#3f3f46] rounded transition-colors"
                            >
                                <X size={20} className="text-gray-500 dark:text-zinc-400" />
                            </button>
                        </div>

                        {/* 同步和清理按钮 */}
                        <div className="p-4 border-b border-gray-200 dark:border-[#27272a] space-y-2">
                            <button
                                onClick={handleRefresh}
                                disabled={syncing}
                                className={`w-full px-3 py-2 rounded-lg text-sm text-white flex items-center justify-center gap-2 transition-colors ${
                                    syncing ? 'bg-zinc-600 cursor-not-allowed' : 'bg-violet-600 hover:bg-violet-500'
                                }`}
                            >
                                {syncing ? (
                                    <>
                                        <Loader2 size={14} className="animate-spin" />
                                        正在同步...
                                    </>
                                ) : (
                                    <>
                                        <RefreshCw size={14} />
                                        同步模型
                                    </>
                                )}
                            </button>
                            {cachedModels.length > 0 && (
                                <button
                                    onClick={onClearAll}
                                    className="w-full px-3 py-2 rounded-lg text-sm text-red-400 bg-red-500/10 hover:bg-red-500/20 flex items-center justify-center gap-2 transition-colors border border-red-500/30"
                                >
                                    <Trash2 size={14} />
                                    清理所有缓存 ({cachedModels.length})
                                </button>
                            )}
                        </div>

                        {/* 模型列表 */}
                        <div className="flex-1 overflow-y-auto custom-scrollbar p-4">
                            {cachedModels.length === 0 ? (
                                <div className="text-center text-gray-500 dark:text-zinc-500 py-8 text-sm">
                                    暂无缓存的模型
                                </div>
                            ) : (
                                <div className="space-y-3">
                                    {cachedModels.map(model => (
                                        <div
                                            key={model.id}
                                            className="bg-gray-50 dark:bg-[#1f1f23] rounded-lg p-3 border border-gray-200 dark:border-[#27272a]"
                                        >
                                            <div className="flex items-center justify-between mb-2">
                                                <div className="flex items-center gap-2">
                                                    <div className="w-8 h-8 rounded-full bg-violet-600/20 flex items-center justify-center">
                                                        <BotIcon size={16} className="text-violet-400" />
                                                    </div>
                                                    <div>
                                                        <div className="text-sm text-gray-900 dark:text-white font-medium">
                                                            {MODEL_LIST.find(m => m.id === model.id)?.name || model.id}
                                                        </div>
                                                        <div className="text-xs text-gray-500 dark:text-zinc-500 flex gap-2">
                                                            <span>{formatModelSize(model.size)}</span>
                                                            <span>·</span>
                                                            <span>{model.fileCount || 0} 个文件</span>
                                                        </div>
                                                    </div>
                                                </div>
                                                <button
                                                    onClick={() => onDeleteModel(model.id)}
                                                    className="p-2 hover:bg-red-50 dark:hover:bg-red-600/20 rounded-lg transition-colors"
                                                    title="删除模型"
                                                >
                                                    <Trash2 size={16} className="text-gray-400 dark:text-zinc-400 hover:text-red-400" />
                                                </button>
                                            </div>
                                            <div className="text-xs text-gray-500 dark:text-zinc-500 truncate">
                                                {model.id}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>

                        {/* 底部提示 */}
                        <div className="p-4 border-t border-gray-200 dark:border-[#27272a]">
                            <div className="text-xs text-gray-500 dark:text-zinc-500 text-center">
                                已缓存 {cachedModels.length} 个模型
                            </div>
                        </div>
                    </div>
                </>
            );
        };

        // ========== 知识库管理组件 ==========
        const KnowledgeDrawer = ({ open, onClose, knowledgeBases, onCreateKnowledgeBase, onDeleteKnowledgeBase, onUploadDocument, onDeleteDocument, documents }) => {
            const [newKbName, setNewKbName] = useState('');
            const [showCreateForm, setShowCreateForm] = useState(false);
            const [expandedKb, setExpandedKb] = useState(null);
            const [uploadingDoc, setUploadingDoc] = useState(null);
            const { success, error } = useMessage();

            const handleCreate = async () => {
                if (!newKbName.trim()) return;
                await onCreateKnowledgeBase({ name: newKbName.trim() });
                setNewKbName('');
                setShowCreateForm(false);
                success('知识库创建成功');
            };

            const handleUpload = async (kbId, file) => {
                setUploadingDoc(kbId);
                try {
                    await onUploadDocument(kbId, file);
                    success(`文档 "${file.name}" 上传成功`);
                } catch (err) {
                    error(`上传失败: ${err.message}`);
                }
                setUploadingDoc(null);
            };

            if (!open) return null;

            return (
                <>
                    <div className="fixed inset-0 bg-black/50 z-40" onClick={onClose} />
                    <div className="fixed right-0 top-0 bottom-0 w-96 bg-white dark:bg-[#18181b] z-50 border-l border-gray-200 dark:border-[#27272a] flex flex-col transform transition-transform duration-300">
                        {/* 头部 */}
                        <div className="p-4 border-b border-gray-200 dark:border-[#27272a] flex items-center justify-between">
                            <h2 className="text-lg font-semibold text-gray-900 dark:text-white">知识库管理</h2>
                            <button onClick={onClose} className="p-1 hover:bg-gray-100 dark:hover:bg-[#3f3f46] rounded transition-colors">
                                <X size={20} className="text-gray-500 dark:text-zinc-400" />
                            </button>
                        </div>

                        {/* 新建知识库 */}
                        <div className="p-4 border-b border-gray-200 dark:border-[#27272a]">
                            {showCreateForm ? (
                                <div className="space-y-2">
                                    <input
                                        type="text"
                                        value={newKbName}
                                        onChange={(e) => setNewKbName(e.target.value)}
                                        placeholder="输入知识库名称..."
                                        className="w-full px-3 py-2 bg-gray-100 dark:bg-[#1f1f23] border border-gray-300 dark:border-[#27272a] rounded-lg text-sm text-gray-900 dark:text-white focus:outline-none focus:border-violet-500"
                                        onKeyDown={(e) => e.key === 'Enter' && handleCreate()}
                                        autoFocus
                                    />
                                    <div className="flex gap-2">
                                        <button
                                            onClick={handleCreate}
                                            className="flex-1 px-3 py-1.5 bg-violet-600 hover:bg-violet-500 text-white rounded-lg text-sm transition-colors"
                                        >
                                            创建
                                        </button>
                                        <button
                                            onClick={() => { setShowCreateForm(false); setNewKbName(''); }}
                                            className="flex-1 px-3 py-1.5 bg-gray-100 dark:bg-[#1f1f23] text-gray-700 dark:text-gray-300 rounded-lg text-sm transition-colors"
                                        >
                                            取消
                                        </button>
                                    </div>
                                </div>
                            ) : (
                                <button
                                    onClick={() => setShowCreateForm(true)}
                                    className="w-full px-3 py-2 bg-violet-600 hover:bg-violet-500 text-white rounded-lg text-sm flex items-center justify-center gap-2 transition-colors"
                                >
                                    <Plus size={16} />
                                    新建知识库
                                </button>
                            )}
                        </div>

                        {/* 知识库列表 */}
                        <div className="flex-1 overflow-y-auto custom-scrollbar p-4">
                            {knowledgeBases.length === 0 ? (
                                <div className="text-center text-gray-500 dark:text-zinc-500 py-8 text-sm">
                                    暂无知识库，请创建一个
                                </div>
                            ) : (
                                <div className="space-y-3">
                                    {knowledgeBases.map(kb => (
                                        <div
                                            key={kb.id}
                                            className={`bg-gray-50 dark:bg-[#1f1f23] rounded-lg border transition-colors ${
                                                'border-gray-200 dark:border-[#27272a]'
                                            }`}
                                        >
                                            {/* 知识库标题 */}
                                            <div className="p-3 flex items-center justify-between">
                                                <button
                                                    onClick={() => {
                                                        setExpandedKb(expandedKb === kb.id ? null : kb.id);
                                                    }}
                                                    className="flex items-center gap-2 flex-1 text-left"
                                                >
                                                    <BookOpen size={16} className="text-violet-400" />
                                                    <div className="flex-1 min-w-0">
                                                        <div className="text-sm font-medium text-gray-900 dark:text-white truncate">
                                                            {kb.name}
                                                        </div>
                                                        <div className="text-xs text-gray-500 dark:text-zinc-500">
                                                            {kb.documentCount || 0} 个文档
                                                        </div>
                                                    </div>
                                                </button>
                                                <div className="flex items-center gap-1">
                                                    <button
                                                        onClick={() => onDeleteKnowledgeBase(kb.id)}
                                                        className="p-1.5 hover:bg-red-50 dark:hover:bg-red-600/20 rounded transition-colors"
                                                        title="删除知识库"
                                                    >
                                                        <Trash2 size={14} className="text-gray-400 dark:text-zinc-400 hover:text-red-400" />
                                                    </button>
                                                </div>
                                            </div>

                                            {/* 文档列表（展开时显示） */}
                                            {expandedKb === kb.id && (
                                                <div className="px-3 pb-3 border-t border-gray-200 dark:border-[#27272a] pt-3 space-y-2">
                                                    {/* 上传文档 */}
                                                    <label className="block">
                                                        <input
                                                            type="file"
                                                            accept=".txt,.md,.text"
                                                            className="hidden"
                                                            onChange={(e) => {
                                                                const file = e.target.files?.[0];
                                                                if (file) handleUpload(kb.id, file);
                                                            }}
                                                            disabled={uploadingDoc === kb.id}
                                                        />
                                                        <div className={`px-3 py-2 rounded-lg text-sm text-center cursor-pointer transition-colors ${
                                                            uploadingDoc === kb.id
                                                                ? 'bg-gray-200 dark:bg-[#27272a] text-gray-400'
                                                                : 'bg-violet-600/10 text-violet-600 hover:bg-violet-600/20'
                                                        }`}>
                                                            {uploadingDoc === kb.id ? (
                                                                <span className="flex items-center justify-center gap-2">
                                                                    <Loader2 size={14} className="animate-spin" />
                                                                    处理中...
                                                                </span>
                                                            ) : (
                                                                <span className="flex items-center justify-center gap-2">
                                                                    <Upload size={14} />
                                                                    上传文档
                                                                </span>
                                                            )}
                                                        </div>
                                                    </label>

                                                    {/* 文档列表 */}
                                                    {(documents[kb.id] || []).map(doc => (
                                                        <div key={doc.id} className="flex items-center justify-between px-2 py-1.5 bg-white dark:bg-[#0a0a0a] rounded text-xs">
                                                            <div className="flex items-center gap-2 flex-1 min-w-0">
                                                                <FileText size={12} className="text-gray-400 flex-shrink-0" />
                                                                <span className="truncate text-gray-700 dark:text-gray-300">{doc.name}</span>
                                                            </div>
                                                            <button
                                                                onClick={() => onDeleteDocument(kb.id, doc.id)}
                                                                className="p-1 hover:bg-red-50 dark:hover:bg-red-600/20 rounded flex-shrink-0"
                                                            >
                                                                <X size={12} className="text-gray-400 hover:text-red-400" />
                                                            </button>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>

                        {/* 底部提示 */}
                        <div className="p-4 border-t border-gray-200 dark:border-[#27272a]">
                            <div className="text-xs text-gray-500 dark:text-zinc-500 text-center">
                                支持 TXT、MD 格式文档
                            </div>
                        </div>
                    </div>
                </>
            );
        };

        // ========== 知识库选择器组件 ==========
        const KnowledgeSelect = ({ knowledgeBases, selectedId, onChange, disabled }) => {
            const selectedKb = knowledgeBases.find(kb => kb.id === selectedId);

            return (
                <div className="flex items-center gap-2">
                    <BookOpen size={16} className="text-violet-400" />
                    <select
                        value={selectedId || ''}
                        onChange={(e) => onChange(e.target.value ? parseInt(e.target.value) : null)}
                        disabled={disabled}
                        className="bg-gray-100 dark:bg-[#1f1f23] border border-gray-300 dark:border-[#27272a] rounded-lg px-3 py-1.5 text-sm text-gray-900 dark:text-white focus:outline-none focus:border-violet-500 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        <option value="">不使用知识库</option>
                        {knowledgeBases.map(kb => (
                            <option key={kb.id} value={kb.id}>
                                {kb.name} ({kb.documentCount || 0} 文档)
                            </option>
                        ))}
                    </select>
                </div>
            );
        };

        // 删除模型缓存（从 Cache API 和 IndexedDB）
        async function deleteModelCache(modelId) {
            console.log('[模型] 开始删除模型:', modelId);

            // 从 MODEL_LIST 中获取模型信息，用于精确匹配
            const modelInfo = MODEL_LIST.find(m => m.id === modelId);
            if (!modelInfo) {
                console.log('[模型] 未找到模型信息:', modelId);
                return;
            }

            // 辅助函数：检查 URL 是否属于指定模型
            const belongsToModel = (url) => {
                const urlLower = url.toLowerCase();

                // 1. 检查 URL 是否包含完整模型 ID（精确匹配）
                if (urlLower.includes(modelId.toLowerCase())) {
                    return true;
                }

                // 2. 检查 URL 是否包含模型名（去掉 -MLC 后缀）
                const baseModelId = modelId.replace('-MLC', '');
                if (urlLower.includes(baseModelId.toLowerCase())) {
                    return true;
                }

                // 3. 检查 URL 是否包含模型名（去掉 -Instruct 后缀，用于 wasm 等文件）
                const noInstructId = modelId.replace('-Instruct-q4f32_1-MLC', '');
                if (urlLower.includes(noInstructId.toLowerCase())) {
                    // 确保不是误匹配其他模型
                    // 比如 "Qwen2.5-0.5B" 不应该匹配 "Qwen2.5-1.5B"
                    return true;
                }

                return false;
            };

            // 辅助函数：检查是否是框架文件（这些不应该被删除）
            const isFrameworkFile = (url) => {
                const urlLower = url.toLowerCase();
                // WebLLM 框架 wasm 文件（不是特定模型的）
                // 比如: web-llm.wasm, mlc-engine.wasm 等
                if (urlLower.includes('/web-llm') || urlLower.includes('/mlc-llm')) {
                    // 检查是否是特定模型
                    const modelNameInUrl = MODEL_LIST.find(m =>
                        urlLower.includes(m.id.toLowerCase()) ||
                        urlLower.includes(m.id.replace('-Instruct-q4f32_1-MLC', '').toLowerCase())
                    );
                    return !modelNameInUrl;
                }
                return false;
            };

            // 1. 从 Cache API 删除
            if (window.caches) {
                try {
                    const cacheNames = await caches.keys();
                    console.log('[模型] 所有缓存:', cacheNames);

                    let deletedCount = 0;
                    for (const cacheName of cacheNames) {
                        const cache = await caches.open(cacheName);
                        const requests = await cache.keys();
                        console.log(`[模型] 缓存 ${cacheName} 共有 ${requests.length} 个请求`);

                        for (const req of requests) {
                            const url = req.url;

                            // 跳过框架文件
                            if (isFrameworkFile(url)) {
                                continue;
                            }

                            // 只删除属于该模型的文件
                            if (belongsToModel(url)) {
                                await cache.delete(req);
                                console.log('[模型] 已从 Cache 删除:', url);
                                deletedCount++;
                            }
                        }
                    }
                    console.log(`[模型] 共删除了 ${deletedCount} 个缓存文件`);
                } catch (e) {
                    console.log('[模型] Cache API 删除失败:', e);
                }
            }

            // 2. 从所有 IndexedDB 数据库删除
            const deleteFromAllDatabases = async () => {
                if (!window.indexedDB || !window.indexedDB.databases) {
                    console.log('[模型] databases API 不支持');
                    return;
                }

                try {
                    const dbs = await window.indexedDB.databases();
                    for (const dbInfo of dbs) {
                        if (!dbInfo.name) continue;

                        try {
                            const dbReq = window.indexedDB.open(dbInfo.name);
                            await new Promise((resolveDb) => {
                                dbReq.onsuccess = () => {
                                    const db = dbReq.result;
                                    const storeNames = Array.from(db.objectStoreNames || []);

                                    for (const storeName of storeNames) {
                                        try {
                                            const tx = db.transaction([storeName], 'readwrite');
                                            const os = tx.objectStore(storeName);
                                            const getReq = os.getAll();

                                            getReq.onsuccess = () => {
                                                const results = getReq.result || [];
                                                for (const item of results) {
                                                    const itemId = String(item.id || item.key || '');
                                                    const itemIdLower = itemId.toLowerCase();
                                                    const modelIdLower = modelId.toLowerCase();

                                                    // 精确匹配：完整的模型 ID
                                                    if (itemIdLower === modelIdLower ||
                                                        itemIdLower.includes(modelIdLower) ||
                                                        itemId.includes(modelId)) {
                                                        os.delete(item.id || item.key);
                                                        console.log(`[模型] 从 ${dbInfo.name}/${storeName} 删除:`, itemId);
                                                    }
                                                }
                                            };
                                        } catch (e) {
                                            // 忽略单个存储的错误
                                        }
                                    }
                                    db.close();
                                    resolveDb();
                                };
                                dbReq.onerror = () => resolveDb();
                            });
                        } catch (e) {
                            console.log(`[模型] 无法访问数据库 ${dbInfo.name}:`, e);
                        }
                    }
                } catch (e) {
                    console.log('[模型] databases API 错误:', e);
                }
            };

            await deleteFromAllDatabases();
            console.log('[模型] 删除操作完成');
        }

        // 动态加载 WebLLM（解决 require 问题）
        let webllm = null;
        async function getWebLLM() {
            if (webllm) return webllm;
            if (window.loadWebLLM) {
                webllm = await window.loadWebLLM();
            } else {
                // Fallback: 直接动态导入
                webllm = await import('https://esm.run/@mlc-ai/web-llm@0.2.79');
            }
            return webllm;
        }

        function App() {
            const { success, error, warning, info } = useMessage();
            const { showConfirm } = useConfirm();
            const [engine, setEngine] = useState(null);
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [loading, setLoading] = useState(false);
            const [modelLoading, setModelLoading] = useState(false);
            const [progress, setProgress] = useState(0);
            const [progressText, setProgressText] = useState('准备中...');
            const [status, setStatus] = useState('未加载');
            const [modelId, setModelId] = useState('');
            const [modelName, setModelName] = useState('');
            const [modelReady, setModelReady] = useState(() => localStorage.getItem('pudding_model_ready') === 'true');
            const [silentLoading, setSilentLoading] = useState(false);
            const [roleId, setRoleId] = useState('default');
            const [isGenerating, setIsGenerating] = useState(false);
            const [conversations, setConversations] = useState([]);
            const [currentConversationId, setCurrentConversationId] = useState(null);
            const [historyDrawerOpen, setHistoryDrawerOpen] = useState(false);
            const [modelManagerOpen, setModelManagerOpen] = useState(false);
            const [knowledgeDrawerOpen, setKnowledgeDrawerOpen] = useState(false);
            const [cachedModels, setCachedModels] = useState([]);
            const [theme, setTheme] = useState(() => localStorage.getItem('pudding_theme') || 'dark');
            const [themeAnimating, setThemeAnimating] = useState(false);
            const [themeAnimationOrigin, setThemeAnimationOrigin] = useState({ x: 0, y: 0, scaleSize: 50 });

            // 知识库相关状态
            const [knowledgeBases, setKnowledgeBases] = useState([]);
            const [knowledgeEnabled, setKnowledgeEnabled] = useState(() => localStorage.getItem('pudding_knowledge_enabled') === 'true');
            const [knowledgeDocuments, setKnowledgeDocuments] = useState({});
            const [retrievedChunks, setRetrievedChunks] = useState([]);

            // 知识库开关状态持久化
            useEffect(() => {
                localStorage.setItem('pudding_knowledge_enabled', knowledgeEnabled);
            }, [knowledgeEnabled]);

            const inputRef = useRef(null);
            const abortRef = useRef(null);
            const engineRef = useRef(null); // 用于避免闭包问题

            // 同步 engine 到 ref
            useEffect(() => {
                engineRef.current = engine;
            }, [engine]);
            const messagesRef = useRef([]); // 保存最新的 messages
            const chatEndRef = useRef(null); // 用于自动滚动到聊天底部

            // 同步 messages 到 ref
            useEffect(() => {
                messagesRef.current = messages;
            }, [messages]);

            // 主题切换函数 - 从图标位置开始扩散动画
            const toggleTheme = (e) => {
                if (themeAnimating) return;

                // 获取点击按钮的位置
                const button = e.currentTarget;
                const rect = button.getBoundingClientRect();
                const x = rect.left + rect.width / 2;
                const y = rect.top + rect.height / 2;

                // 计算扩散到全屏需要的缩放比例
                const maxRadius = Math.max(x, y, window.innerWidth - x, window.innerHeight - y);
                const scaleSize = maxRadius / Math.min(rect.width, rect.height) * 2;

                // 保存动画位置信息
                setThemeAnimationOrigin({ x, y, scaleSize });

                setThemeAnimating(true);
                const newTheme = theme === 'dark' ? 'light' : 'dark';

                // 动画结束后切换主题
                setTimeout(() => {
                    setTheme(newTheme);
                    localStorage.setItem('pudding_theme', newTheme);
                    setThemeAnimating(false);
                }, 400);
            };

            // 应用主题到 document
            useEffect(() => {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                    document.body.style.backgroundColor = '#09090b';
                } else {
                    document.documentElement.classList.remove('dark');
                    document.body.style.backgroundColor = '#ffffff';
                }
            }, [theme]);

            // 组件挂载后移除启动遮罩层
            useEffect(() => {
                const splash = document.getElementById('splash-screen');
                if (splash) {
                    // 添加淡出动画
                    splash.style.transition = 'opacity 0.3s ease-out';
                    splash.style.opacity = '0';
                    setTimeout(() => {
                        splash.style.display = 'none';
                    }, 300);
                }
            }, []);

            // 初始化时设置上次使用的模型（由 useEffect 自动加载）
            useEffect(() => {
                const cached = localStorage.getItem('webllm_last_model');
                const wasReady = localStorage.getItem('pudding_model_ready') === 'true';

                if (cached) {
                    const model = MODEL_LIST.find(m => m.id === cached);
                    if (model) {
                        // 如果之前模型已加载完成，先显示就绪状态（跳过加载动画）
                        if (wasReady) {
                            setStatus('已就绪');
                            setModelReady(true);
                        }
                        setModelId(cached);
                        setModelName(model.name);
                        // modelId 变化时会触发下面的 useEffect 自动加载
                    }
                }
            }, []); // 只在组件挂载时执行一次

            // 获取已缓存的模型列表
            const getCachedModels = async () => {
                if (!window.indexedDB) return [];
                return new Promise((resolve) => {
                    const req = window.indexedDB.open('webllm-cache', 1);
                    req.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        // 创建对象存储（如果不存在）
                        if (!db.objectStoreNames.contains('model-cache')) {
                            db.createObjectStore('model-cache', { keyPath: 'id' });
                        }
                    };
                    req.onsuccess = () => {
                        const db = req.result;
                        // 检查对象存储是否存在
                        if (!db.objectStoreNames.contains('model-cache')) {
                            resolve([]);
                            return;
                        }
                        const transaction = db.transaction(['model-cache'], 'readonly');
                        const objectStore = transaction.objectStore('model-cache');
                        const getAllReq = objectStore.getAllKeys();
                        getAllReq.onsuccess = () => {
                            resolve(getAllReq.result || []);
                        };
                        getAllReq.onerror = () => resolve([]);
                    };
                    req.onerror = () => resolve([]);
                });
            };

            // 获取已缓存模型列表（带详细信息）
            const getCachedModelsWithInfo = async () => {
                const allModels = [];

                // 辅助函数：从 URL 中提取模型主ID
                const extractModelId = (url) => {
                    // 尝试匹配 MODEL_LIST 中的模型ID
                    for (const model of MODEL_LIST) {
                        if (url.includes(model.id)) {
                            return model.id;
                        }
                        // 也尝试匹配部分ID
                        const partialId = model.id.split('-Instruct')[0];
                        if (url.includes(partialId)) {
                            return model.id;
                        }
                    }
                    return null;
                };

                // 尝试使用 Cache API 查找模型缓存
                if (window.caches) {
                    try {
                        const cacheNames = await caches.keys();
                        console.log('[模型] Cache API 缓存:', cacheNames);

                        for (const cacheName of cacheNames) {
                            if (cacheName.includes('webllm') || cacheName.includes('model')) {
                                const cache = await caches.open(cacheName);
                                const requests = await cache.keys();
                                const modelFiles = {};

                                for (const req of requests) {
                                    const modelId = extractModelId(req.url);
                                    if (modelId) {
                                        if (!modelFiles[modelId]) {
                                            modelFiles[modelId] = { urls: [], size: 0 };
                                        }
                                        modelFiles[modelId].urls.push(req.url);

                                        // 获取文件大小 - 使用 Content-Length 头，更快速
                                        try {
                                            const response = await cache.match(req);
                                            if (response) {
                                                // 优先使用 Content-Length 头（快速，不需要加载整个 blob）
                                                const contentLength = response.headers.get('content-length');
                                                if (contentLength) {
                                                    modelFiles[modelId].size += parseInt(contentLength, 10);
                                                } else {
                                                    // 如果没有 Content-Length，尝试 blob（慢，仅对小文件）
                                                    try {
                                                        const blob = await response.blob();
                                                        modelFiles[modelId].size += blob.size;
                                                    } catch (e) {
                                                        // 忽略失败
                                                    }
                                                }
                                            }
                                        } catch (e) {
                                            // 忽略单个文件大小获取失败
                                        }
                                    }
                                }

                                // 添加到结果（聚合相同模型的大小）
                                for (const [modelId, data] of Object.entries(modelFiles)) {
                                    const existing = allModels.find(m => m.id === modelId);
                                    if (existing) {
                                        // 已存在则累加大小
                                        existing.size += data.size;
                                        existing.fileCount += data.urls.length;
                                    } else {
                                        allModels.push({
                                            id: modelId,
                                            size: data.size,
                                            source: cacheName,
                                            fileCount: data.urls.length
                                        });
                                    }
                                    console.log('[模型] 发现缓存模型:', modelId, `(${formatSize(data.size)}, ${data.urls.length}个文件)`);
                                }
                            }
                        }
                    } catch (e) {
                        console.log('[模型] Cache API 访问失败:', e);
                    }
                }

                // 尝试使用 databases API 获取所有数据库
                if (window.indexedDB && window.indexedDB.databases) {
                    try {
                        const dbs = await window.indexedDB.databases();
                        console.log('[模型] 所有数据库:', dbs.map(d => d.name));

                        const seenIds = new Set(allModels.map(m => m.id));

                        for (const dbInfo of dbs) {
                            if (!dbInfo.name || dbInfo.name === 'pudding-chat-db') continue;
                            try {
                                const dbReq = window.indexedDB.open(dbInfo.name);
                                await new Promise((resolve) => {
                                    dbReq.onsuccess = () => {
                                        const db = dbReq.result;
                                        const storeNames = Array.from(db.objectStoreNames);

                                        for (const storeName of storeNames) {
                                            const tx = db.transaction([storeName], 'readonly');
                                            const os = tx.objectStore(storeName);
                                            const getReq = os.getAll();
                                            getReq.onsuccess = () => {
                                                const results = getReq.result || [];
                                                for (const item of results) {
                                                    // 尝试从 item.id 中匹配 MODEL_LIST
                                                    const itemId = String(item.id || item.key || '');
                                                    for (const model of MODEL_LIST) {
                                                        if (itemId.includes(model.id) || itemId.includes(model.id.split('-Instruct')[0])) {
                                                            if (!seenIds.has(model.id)) {
                                                                seenIds.add(model.id);
                                                                allModels.push({
                                                                    id: model.id,
                                                                    size: item.size || 0,
                                                                    source: dbInfo.name + '/' + storeName
                                                                });
                                                                console.log('[模型] 从数据库发现模型:', model.id);
                                                            }
                                                            break;
                                                        }
                                                    }
                                                }
                                            };
                                        }
                                        db.close();
                                        resolve();
                                    };
                                    dbReq.onerror = () => resolve();
                                });
                            } catch (e) {
                                console.log('[模型] 无法访问数据库:', dbInfo.name);
                            }
                        }
                    } catch (e) {
                        console.log('[模型] databases API 不支持:', e);
                    }
                }

                console.log('[模型] 找到的缓存模型:', allModels);
                return allModels;
            };

            // 格式化文件大小
            const formatSize = (bytes) => {
                if (!bytes || bytes === 0) return '0 B';
                const gb = bytes / (1024 * 1024 * 1024);
                if (gb >= 1) return `${gb.toFixed(2)} GB`;
                const mb = bytes / (1024 * 1024);
                if (mb >= 1) return `${mb.toFixed(1)} MB`;
                const kb = bytes / 1024;
                return `${kb.toFixed(1)} KB`;
            };

            // 刷新模型列表
            const refreshCachedModels = async () => {
                const models = await getCachedModelsWithInfo();
                setCachedModels(models);
            };

            // 删除模型
            const handleDeleteModel = async (modelId) => {
                const modelName = MODEL_LIST.find(m => m.id === modelId)?.name || modelId;
                const confirmed = await showConfirm({
                    title: '删除模型',
                    content: `确定要删除模型 "${modelName}" 吗？删除后需要重新下载。`,
                    confirmText: '删除',
                    cancelText: '取消',
                    type: 'danger'
                });
                if (!confirmed) return;
                try {
                    info(`正在删除模型 "${modelName}"...`);
                    await deleteModelCache(modelId);
                    console.log('[模型] 已删除模型:', modelId);
                    await refreshCachedModels();
                    success(`模型 "${modelName}" 已删除`);
                } catch (err) {
                    console.error('[模型] 删除模型失败:', err);
                    error(`删除模型失败: ${err.message}`);
                }
            };

            // 清理所有模型缓存
            const handleClearAllCache = async () => {
                if (cachedModels.length === 0) {
                    info('没有缓存的模型');
                    return;
                }
                const confirmed = await showConfirm({
                    title: '清理所有缓存',
                    content: `确定要删除所有 ${cachedModels.length} 个缓存模型吗？删除后需要重新下载。`,
                    confirmText: '清理',
                    cancelText: '取消',
                    type: 'danger'
                });
                if (!confirmed) return;
                try {
                    info('正在清理所有模型缓存...');
                    for (const model of cachedModels) {
                        await deleteModelCache(model.id);
                    }
                    await refreshCachedModels();
                    success('所有模型缓存已清理');
                } catch (err) {
                    console.error('[模型] 清理缓存失败:', err);
                    error(`清理缓存失败: ${err.message}`);
                }
            };

            // ========== 知识库相关函数 ==========
            // 加载知识库列表和文档
            const loadKnowledgeBases = async () => {
                try {
                    const kbs = await KnowledgeDB.getAllKnowledgeBases();
                    setKnowledgeBases(kbs);

                    // 同时加载每个知识库的文档
                    const docsMap = {};
                    for (const kb of kbs) {
                        const docs = await KnowledgeDB.getDocumentsByKnowledgeBase(kb.id);
                        docsMap[kb.id] = docs;
                    }
                    setKnowledgeDocuments(docsMap);
                } catch (err) {
                    console.error('[知识库] 加载失败:', err);
                }
            };

            // 创建知识库
            const handleCreateKnowledgeBase = async (data) => {
                try {
                    await KnowledgeDB.createKnowledgeBase(data);
                    await loadKnowledgeBases();
                } catch (err) {
                    console.error('[知识库] 创建失败:', err);
                }
            };

            // 删除知识库
            const handleDeleteKnowledgeBase = async (kbId) => {
                const confirmed = await showConfirm({
                    title: '删除知识库',
                    content: '确定要删除这个知识库吗？所有文档将被永久删除。',
                    confirmText: '删除',
                    cancelText: '取消',
                    type: 'danger'
                });
                if (!confirmed) return;
                try {
                    await KnowledgeDB.deleteKnowledgeBase(kbId);
                    if (selectedKnowledgeBaseId === kbId) {
                        setSelectedKnowledgeBaseId(null);
                        setRetrievedChunks([]);
                    }
                    await loadKnowledgeBases();
                    success('知识库已删除');
                } catch (err) {
                    console.error('[知识库] 删除失败:', err);
                    error(`删除失败: ${err.message}`);
                }
            };

            // 上传文档（关键词检索）
            const handleUploadDocument = async (kbId, file, onProgress) => {
                const fileType = file.name.split('.').pop()?.toLowerCase();
                if (!['txt', 'md', 'text'].includes(fileType)) {
                    throw new Error('仅支持 TXT、MD 格式文件');
                }

                info('正在读取文件...');

                // 读取文件内容
                const content = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });

                if (!content || content.trim().length === 0) {
                    throw new Error('文件内容为空');
                }

                // 文本分块
                const chunks = chunkText(content, 500, 50);
                info(`文本已分成 ${chunks.length} 个片段`);

                // 添加文档记录
                const doc = await KnowledgeDB.addDocument({
                    knowledgeBaseId: kbId,
                    name: file.name,
                    type: fileType,
                    content: content,
                    chunkCount: chunks.length,
                    status: 'completed'
                });

                // 添加文本块
                await KnowledgeDB.addChunks(doc.id, chunks);

                success(`文档上传完成，已分成 ${chunks.length} 个片段`);

                // 刷新知识库数据
                await loadKnowledgeBases();
                const docs = await KnowledgeDB.getDocumentsByKnowledgeBase(kbId);
                setKnowledgeDocuments(prev => ({ ...prev, [kbId]: docs }));
            };

            // 删除文档
            const handleDeleteDocument = async (kbId, docId) => {
                const confirmed = await showConfirm({
                    title: '删除文档',
                    content: '确定要删除这个文档吗？',
                    confirmText: '删除',
                    cancelText: '取消',
                    type: 'danger'
                });
                if (!confirmed) return;
                try {
                    await KnowledgeDB.deleteDocument(docId);
                    await loadKnowledgeBases();
                    const docs = await KnowledgeDB.getDocumentsByKnowledgeBase(kbId);
                    setKnowledgeDocuments(prev => ({ ...prev, [kbId]: docs }));
                    success('文档已删除');
                } catch (err) {
                    console.error('[知识库] 删除文档失败:', err);
                    error(`删除失败: ${err.message}`);
                }
            };

            // 知识库问答检索（检索所有知识库）
            const retrieveFromKnowledgeBase = async (query) => {
                if (!knowledgeEnabled || !query.trim()) {
                    return [];
                }

                try {
                    // 获取所有知识库的文本块
                    let allChunks = [];
                    for (const kb of knowledgeBases) {
                        const chunks = await KnowledgeDB.getAllChunks(kb.id);
                        // 为每个块添加来源信息
                        const chunksWithSource = chunks.map(chunk => ({
                            ...chunk,
                            sourceName: kb.name
                        }));
                        allChunks = allChunks.concat(chunksWithSource);
                    }

                    if (allChunks.length === 0) return [];

                    // 关键词检索
                    const results = searchChunks(allChunks, query, 5);
                    return results;
                } catch (err) {
                    console.error('[知识库] 检索失败:', err);
                    return [];
                }
            };

            // 页面加载时加载知识库列表
            useEffect(() => {
                loadKnowledgeBases();
            }, []);

            // 页面加载时检查已缓存的模型
            useEffect(() => {
                getCachedModelsWithInfo().then(models => {
                    setCachedModels(models);
                });
            }, []);

            // 页面关闭前保存对话
            useEffect(() => {
                const handleBeforeUnload = () => {
                    if (messages.length > 0) {
                        // 使用同步方式保存到 localStorage 作为备份
                        const title = messages[0]?.content?.slice(0, 30) || '新对话';
                        const backupData = {
                            title,
                            modelId,
                            roleId,
                            messages: messages.map(m => ({
                                role: m.role,
                                content: m.content,
                                timestamp: m.timestamp
                            })),
                            updatedAt: Date.now()
                        };
                        localStorage.setItem('pudding_conversation_backup', JSON.stringify(backupData));
                    }
                };

                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [messages, modelId, roleId]);

            // 页面加载时尝试恢复未保存的对话
            useEffect(() => {
                const backup = localStorage.getItem('pudding_conversation_backup');
                if (backup) {
                    try {
                        const data = JSON.parse(backup);
                        // 如果对话内容不为空且没有 currentConversationId，询问用户是否恢复
                        if (data.messages && data.messages.length > 0 && !currentConversationId) {
                            console.log('[历史] 发现未保存的对话备份:', data.title);
                            // 自动恢复对话
                            setMessages(data.messages);
                            setModelId(data.modelId || '');
                            setRoleId(data.roleId || 'default');
                            localStorage.removeItem('pudding_conversation_backup');
                        }
                    } catch (e) {
                        console.error('[历史] 恢复备份失败:', e);
                    }
                }
            }, []);

            // 加载历史记录列表
            useEffect(() => {
                ConversationDB.getAll().then(convs => {
                    console.log('[历史] 加载到', convs.length, '条历史记录');
                    setConversations(convs);
                }).catch(err => console.error('[历史] 加载历史记录失败:', err));
            }, []);

            // 自动保存对话到历史记录
            const saveConversation = useCallback(async () => {
                const currentMessages = messagesRef.current;

                // 检查是否有用户消息（必须要有用户消息才保存）
                const hasUserMessage = currentMessages.some(m =>
                    m.role === 'user' && m.content && m.content.trim()
                );
                if (!hasUserMessage) {
                    console.log('[历史] 没有用户消息，跳过保存');
                    return;
                }

                // 检查是否是欢迎消息（包含特定关键词的AI消息）
                const isWelcomeMessage = (content) => {
                    return content && (
                        content.includes('你好！我是运行在浏览器里的本地 AI 模型') ||
                        content.includes('有什么可以帮你的吗')
                    );
                };

                // 过滤消息：排除欢迎消息和中断的消息
                const validMessages = currentMessages.filter(m => {
                    // 用户消息
                    if (m.role === 'user') {
                        return m.content && m.content.trim();
                    }
                    // AI消息：排除欢迎消息和中断的
                    if (m.role === 'assistant') {
                        return m.content && m.content.trim() &&
                               !m.content.includes('(...已中断)') &&
                               !isWelcomeMessage(m.content);
                    }
                    return false;
                });

                // 如果没有有效消息，跳过保存
                if (validMessages.length === 0) {
                    console.log('[历史] 没有有效消息，跳过保存');
                    return;
                }

                // 生成标题（第一条用户消息的前30个字符）
                const firstUserMessage = validMessages.find(m => m.role === 'user');
                const title = firstUserMessage?.content?.slice(0, 30) || '新对话';

                const conversationData = {
                    title,
                    modelId,
                    roleId,
                    messages: validMessages.map(m => ({
                        role: m.role,
                        content: m.content,
                        timestamp: m.timestamp || Date.now()
                    }))
                };

                try {
                    console.log('[历史] 保存对话:', conversationData.title, conversationData.messages.length, '条消息');

                    // 检查是否应该创建新对话（modelId 或 roleId 变化了）
                    let shouldCreateNew = false;
                    if (currentConversationId) {
                        const existingConv = await ConversationDB.get(currentConversationId);
                        if (existingConv && (existingConv.modelId !== modelId || existingConv.roleId !== roleId)) {
                            console.log('[历史] 模型或角色变化，创建新对话');
                            shouldCreateNew = true;
                        }
                    }

                    if (currentConversationId && !shouldCreateNew) {
                        await ConversationDB.update(currentConversationId, conversationData);
                        console.log('[历史] 更新成功');
                    } else {
                        const newConv = await ConversationDB.create(conversationData);
                        setCurrentConversationId(newConv.id);
                        console.log('[历史] 创建成功, id:', newConv.id);
                    }
                    // 刷新列表
                    const convs = await ConversationDB.getAll();
                    setConversations(convs);
                } catch (err) {
                    console.error('[历史] 保存对话失败:', err);
                    error('保存对话失败');
                }
            }, [modelId, roleId, currentConversationId]);

            // 新建对话
            const handleNewChat = async () => {
                // 先保存当前对话
                await saveConversation();
                // 清空状态
                setMessages([]);
                setCurrentConversationId(null);
                setInput('');
            };

            // 加载历史对话
            const handleLoadConversation = async (conversation) => {
                // 先保存当前对话
                await saveConversation();
                // 加载历史对话
                setMessages(conversation.messages || []);
                setCurrentConversationId(conversation.id);
                setModelId(conversation.modelId || '');
                const model = MODEL_LIST.find(m => m.id === conversation.modelId);
                setModelName(model?.name || '');
                setRoleId(conversation.roleId || 'default');
                setHistoryDrawerOpen(false);
            };

            // 删除历史对话
            const handleDeleteConversation = async (id) => {
                const confirmed = await showConfirm({
                    title: '删除对话',
                    content: '确定要删除这条对话吗？此操作不可恢复。',
                    confirmText: '删除',
                    cancelText: '取消',
                    type: 'danger'
                });
                if (!confirmed) return;
                await ConversationDB.delete(id);
                if (currentConversationId === id) {
                    setMessages([]);
                    setCurrentConversationId(null);
                }
                const convs = await ConversationDB.getAll();
                setConversations(convs);
                success('对话已删除');
            };

            // 消息更新时自动滚动到底部
            useEffect(() => {
                if (chatEndRef.current) {
                    chatEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [messages, isGenerating]);

            // 加载模型
            const loadModel = async (targetModelId) => {
                // 如果已经在加载目标模型，跳过
                if (loading && modelId === targetModelId) return;

                // 检查是否之前已加载完成（跳过加载动画）
                const wasModelReady = localStorage.getItem('pudding_model_ready') === 'true';
                const isSameModel = localStorage.getItem('webllm_last_model') === targetModelId;

                // 如果之前已加载且是同一模型，静默加载（不显示加载动画）
                const silentLoad = wasModelReady && isSameModel;

                // 开始加载新模型
                if (!silentLoad) {
                    setLoading(true);
                    setModelLoading(true);
                    setProgress(0);
                    setStatus('加载中');
                    setProgressText('检查环境...');
                } else {
                    // 静默加载时显示轻量级 loading
                    setSilentLoading(true);
                }

                // 保存目标模型ID，用于在加载完成后验证
                const targetId = targetModelId;

                try {
                    if (!navigator.gpu) {
                        throw new Error('浏览器不支持 WebGPU，请使用 Chrome 113+ 或 Edge');
                    }

                    // 如果已经有 engine，先清理
                    if (engine) {
                        setEngine(null);
                        setMessages([]);
                    }

                    if (!silentLoad) {
                        setProgressText('正在加载模型...');
                    }

                    // 动态加载 webllm 模块
                    const webllmModule = await getWebLLM();
                    const mlcEngine = await webllmModule.CreateMLCEngine(targetId, {
                        initProgressCallback: (p) => {
                            // 只更新当前选中模型的进度
                            if (targetId !== modelId) return;

                            let percent = 0;
                            if (p && typeof p === 'object' && 'progress' in p) {
                                percent = Math.floor(p.progress * 100);
                            } else if (typeof p === 'number') {
                                percent = Math.floor(p * 100);
                            }
                            setProgress(percent);
                            // 只在真正下载时显示下载进度
                            const msg = p.message || '';
                            if (msg.includes('Downloading') || msg.includes('download')) {
                                setProgressText('正在下载模型...');
                            } else if (msg.includes('Cache') || msg.includes('cache')) {
                                setProgressText('从缓存加载...');
                            } else {
                                setProgressText(msg || '加载中...');
                            }
                        },
                        useIndexedDBCache: true,
                    });

                    // 只有当目标模型仍然是当前选择的模型时，才设置 engine
                    if (targetId === modelId) {
                        setEngine(mlcEngine);
                        engineRef.current = mlcEngine; // 同步到 ref
                        setStatus('已就绪');

                        // 只有在非静默加载时才设置 loading 状态
                        if (!silentLoad) {
                            setLoading(false);
                            setModelLoading(false);
                        }

                        // 刷新缓存模型列表（带详细信息）
                        getCachedModelsWithInfo().then(models => setCachedModels(models));

                        // 保存模型选择
                        localStorage.setItem('webllm_last_model', targetId);

                        // 标记模型已就绪（刷新页面时跳过加载动画）
                        setModelReady(true);
                        localStorage.setItem('pudding_model_ready', 'true');

                        // 关闭静默加载状态
                        setSilentLoading(false);

                        // 只有在非静默加载时才显示欢迎消息和提示
                        if (!silentLoad) {
                            // 添加欢迎消息（开始新对话）
                            setCurrentConversationId(null);
                            const modelInfo = MODEL_LIST.find(m => m.id === targetId);
                            const roleInfo = ROLE_LIST.find(r => r.id === roleId);
                            const rolePrefix = roleId === 'default' ? '' : `【${roleInfo?.name || ''}】`;
                            setMessages([{
                                role: 'assistant',
                                content: `${rolePrefix}你好！我是运行在浏览器里的本地 AI 模型 (${modelInfo?.name || targetId})。\n有什么可以帮你的吗？`,
                                timestamp: Date.now()
                            }]);

                            success(`模型 "${modelInfo?.name || targetId}" 已加载`);
                        }
                    }
                } catch (err) {
                    console.error('加载错误:', err);

                    // 只有在非静默加载时才设置 loading 状态
                    if (!silentLoad) {
                        setLoading(false);
                        setModelLoading(false);
                    }

                    // 关闭静默加载状态
                    setSilentLoading(false);

                    setStatus('错误');
                    // 加载失败时重置就绪状态，下次需要显示加载动画
                    setModelReady(false);
                    localStorage.removeItem('pudding_model_ready');
                    const errorMsg = err.message || '加载失败';
                    setProgressText(errorMsg);

                    // 只有在非静默加载时才显示错误提示
                    if (!silentLoad) {
                        error(`加载失败: ${errorMsg}`);
                    }
                }
            };

            // 发送消息
            const sendMessage = async () => {
                if (!input.trim() || isGenerating || !engine) return;

                const userMsg = { role: 'user', content: input.trim(), timestamp: Date.now() };
                setMessages(prev => [...prev, userMsg]);
                setInput('');
                setIsGenerating(true);
                setRetrievedChunks([]); // 清空上次的检索结果

                // 自动聚焦输入框
                setTimeout(() => inputRef.current?.focus(), 100);

                // 用于存储当前检索结果
                let currentRetrievedChunks = [];

                try {
                    setMessages(prev => [...prev, { role: 'assistant', content: '', timestamp: Date.now(), retrievedChunks: [] }]);

                    // 创建 AbortController 用于中断
                    abortRef.current = new AbortController();

                    // 构建消息列表，包含历史消息
                    const roleInfo = ROLE_LIST.find(r => r.id === roleId);
                    const allMessages = [];

                    // 1. 添加系统提示词（如果有）
                    if (roleId !== 'default' && roleInfo?.systemPrompt) {
                        allMessages.push({ role: 'system', content: roleInfo.systemPrompt });
                    }

                    // 2. 如果启用了知识库，进行检索
                    let ragPrompt = userMsg.content;
                    if (knowledgeEnabled) {
                        info('正在检索知识库...');
                        const chunks = await retrieveFromKnowledgeBase(userMsg.content);
                        currentRetrievedChunks = chunks;
                        setRetrievedChunks(chunks);
                        if (chunks.length > 0) {
                            ragPrompt = buildRAGPrompt(userMsg.content, chunks);
                            success(`已检索到 ${chunks.length} 条相关内容`);
                        } else {
                            info('知识库中未找到相关内容');
                        }
                    }

                    // 3. 添加历史消息（排除最后一条空消息，限制最近 10 轮对话以避免 token 超出限制）
                    const historyMessages = messages.slice(0, -1).slice(-20);
                    historyMessages.forEach(msg => {
                        allMessages.push({ role: msg.role, content: msg.content });
                    });

                    // 4. 添加当前用户消息（使用 RAG Prompt 或原始消息）
                    allMessages.push({ role: 'user', content: ragPrompt });

                    const stream = await engine.chat.completions.create({
                        messages: allMessages,
                        stream: true,
                        signal: abortRef.current.signal,
                    });

                    let fullResponse = '';
                    for await (const chunk of stream) {
                        if (abortRef.current?.signal.aborted) {
                            // 用户中断，追加提示
                            setMessages(prev => {
                                const last = prev[prev.length - 1];
                                if (last.role === 'assistant') {
                                    return [...prev.slice(0, -1), { role: 'assistant', content: fullResponse + ' (...已中断)', timestamp: last.timestamp, retrievedChunks: currentRetrievedChunks }];
                                }
                                return prev;
                            });
                            return;
                        }
                        const token = chunk.choices[0]?.delta?.content || '';
                        fullResponse += token;
                        setMessages(prev => {
                            const last = prev[prev.length - 1];
                            if (last.role === 'assistant') {
                                return [...prev.slice(0, -1), { role: 'assistant', content: fullResponse, timestamp: last.timestamp, retrievedChunks: currentRetrievedChunks }];
                            }
                            return prev;
                        });
                    }
                } catch (err) {
                    if (err.name === 'AbortError') {
                        // 被中断
                        console.log('生成已中断');
                    } else {
                        console.error('生成错误:', err);
                        setMessages(prev => [...prev, { role: 'assistant', content: `错误: ${err.message}`, timestamp: Date.now(), retrievedChunks: [] }]);
                    }
                }

                setIsGenerating(false);
                abortRef.current = null;

                // 保存对话到历史记录
                saveConversation();

                // AI 回复结束后聚焦输入框（延迟确保 disabled 已解除）
                setTimeout(() => {
                    inputRef.current?.focus();
                }, 50);
            };

            // 中断生成
            const abortGeneration = () => {
                if (abortRef.current) {
                    abortRef.current.abort();
                    setIsGenerating(false);
                    // 中断后聚焦输入框
                    setTimeout(() => {
                        inputRef.current?.focus();
                    }, 50);
                }
            };

            // 按 Enter 发送
            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            };

            // 选择模型
            const handleModelChange = async (e) => {
                const newModelId = e.target.value;
                if (!newModelId) {
                    setModelId('');
                    setModelName('');
                    setEngine(null);
                    engineRef.current = null;
                    return;
                }

                const model = MODEL_LIST.find(m => m.id === newModelId);
                setModelId(newModelId);
                setModelName(model?.name || '');

                // 清除旧引擎，触发重新加载
                setEngine(null);
                engineRef.current = null;
            };

            // 模型ID变化时自动处理模型加载状态
            useEffect(() => {
                if (!modelId) return;

                // 如果 engineRef 已存在且 modelId 匹配，说明模型已加载
                if (engineRef.current) {
                    console.log('[模型] 模型已加载:', modelId);
                    setStatus('已就绪');
                    return;
                }

                // engine 不存在，尝试加载模型
                console.log('[模型] 尝试加载模型:', modelId);
                loadModel(modelId);
            }, [modelId]);

            // 获取当前模型显示名
            const getCurrentModelDisplay = () => {
                if (modelName) return modelName;
                const model = MODEL_LIST.find(m => m.id === modelId);
                return model?.name || modelId || '未选择';
            };

            return (
                <>
                    <HistoryDrawer
                        open={historyDrawerOpen}
                        onClose={() => setHistoryDrawerOpen(false)}
                        conversations={conversations}
                        onLoadConversation={handleLoadConversation}
                        onNewChat={handleNewChat}
                        onDeleteConversation={handleDeleteConversation}
                    />
                    <ModelManager
                        open={modelManagerOpen}
                        onClose={() => setModelManagerOpen(false)}
                        cachedModels={cachedModels}
                        onRefreshModels={refreshCachedModels}
                        onDeleteModel={handleDeleteModel}
                        onClearAll={handleClearAllCache}
                    />
                    <KnowledgeDrawer
                        open={knowledgeDrawerOpen}
                        onClose={() => setKnowledgeDrawerOpen(false)}
                        knowledgeBases={knowledgeBases}
                        onCreateKnowledgeBase={handleCreateKnowledgeBase}
                        onDeleteKnowledgeBase={handleDeleteKnowledgeBase}
                        onUploadDocument={handleUploadDocument}
                        onDeleteDocument={handleDeleteDocument}
                        documents={knowledgeDocuments}
                    />
                    <div className="h-screen w-screen bg-white dark:bg-[#0a0a0a] text-gray-900 dark:text-white flex overflow-hidden transition-colors duration-300">
                        {/* 左侧导航栏 */}
                        <div className="w-16 bg-white dark:bg-[#0a0a0a] border-r border-gray-200 dark:border-[#27272a] flex flex-col items-center py-4 gap-4 transition-colors duration-300">
                            {/* Logo - Ming格格风格 */}
                            <div className="w-10 h-10 rounded-2xl overflow-hidden mb-4 shadow-lg shadow-rose-500/30 border-2 border-rose-500/50">
                                <img src="Ming.jpg" alt="Ming" className="w-full h-full object-cover" />
                            </div>

                            {/* 导航按钮 */}
                            <button
                                onClick={() => setHistoryDrawerOpen(true)}
                                className="p-2.5 hover:bg-gray-200 dark:hover:bg-[#27272a] rounded-xl transition-colors group relative"
                                title="历史记录"
                            >
                                <MessageSquare size={20} className="text-gray-500 dark:text-zinc-400 group-hover:text-gray-900 dark:group-hover:text-white" />
                            </button>

                            <button
                                onClick={() => setModelManagerOpen(true)}
                                className="p-2.5 hover:bg-gray-200 dark:hover:bg-[#27272a] rounded-xl transition-colors group relative"
                                title="模型管理"
                            >
                                <Settings size={20} className="text-gray-500 dark:text-zinc-400 group-hover:text-gray-900 dark:group-hover:text-white" />
                            </button>

                            <button
                                onClick={() => setKnowledgeDrawerOpen(true)}
                                className="p-2.5 hover:bg-gray-200 dark:hover:bg-[#27272a] rounded-xl transition-colors group relative"
                                title="知识库管理"
                            >
                                <BookOpen size={20} className="text-gray-500 dark:text-zinc-400 group-hover:text-gray-900 dark:group-hover:text-white" />
                            </button>

                            <div className="flex-1"></div>

                            {/* 状态指示 */}
                            <div className="flex flex-col items-center gap-1">
                                {engine ? (
                                    <div className="w-2 h-2 rounded-full bg-emerald-500"></div>
                                ) : (
                                    <div className="w-2 h-2 rounded-full bg-gray-400 dark:bg-zinc-600"></div>
                                )}
                            </div>
                        </div>

                        {/* 右侧主内容区 */}
                        <div className="flex-1 flex flex-col bg-white dark:bg-[#0a0a0a]">
                        {/* Header */}
                        <div className="h-14 bg-white dark:bg-[#0a0a0a] border-b border-gray-200 dark:border-[#27272a] flex items-center justify-between px-6 transition-colors duration-300">
                            <div className="flex items-center gap-3">
                                <h1 className="text-lg font-semibold text-gray-900 dark:text-white">布丁离线AI助手</h1>
                                <ModelBadge name={getCurrentModelDisplay()} />
                                <StatusBadge status={status} />
                            </div>
                            <div className="flex items-center gap-3">
                                {/* 主题切换按钮 - 从图标位置扩散动画 */}
                                <div className="relative">
                                    <button
                                        onClick={toggleTheme}
                                        className={`p-2 rounded-xl transition-all duration-200 ${
                                            theme === 'dark'
                                                ? 'hover:bg-[#27272a] text-yellow-400'
                                                : 'hover:bg-gray-200 text-indigo-600'
                                        }`}
                                    >
                                        {theme === 'dark' ? <Sun className="transition-transform duration-300" /> : <Moon className="transition-transform duration-300" />}
                                    </button>
                                    {/* 扩散动画背景 - 从图标位置开始覆盖整个屏幕 */}
                                    {themeAnimating && (
                                        <div
                                            className="fixed pointer-events-none animate-theme-expand z-50"
                                            style={{
                                                left: themeAnimationOrigin ? `${themeAnimationOrigin.x}px` : '50%',
                                                top: themeAnimationOrigin ? `${themeAnimationOrigin.y}px` : '50%',
                                                transform: 'translate(-50%, -50%)',
                                                borderRadius: '50%',
                                                background: theme === 'dark' ? '#ffffff' : '#09090b'
                                            }}
                                        />
                                    )}
                                </div>
                                <RoleSelect value={roleId} onChange={setRoleId} engine={engine} />
                                {/* 知识库开关（滑块样式） */}
                                <div className="flex items-center gap-2">
                                    <BookOpen size={14} className={knowledgeEnabled ? 'text-violet-400' : 'text-gray-400'} />
                                    <button
                                        onClick={() => {
                                            const newState = !knowledgeEnabled;
                                            setKnowledgeEnabled(newState);
                                            if (newState) {
                                                info('知识库已启用，AI 将基于知识库内容回答问题');
                                            } else {
                                                info('知识库已关闭');
                                            }
                                        }}
                                        disabled={!engine || isGenerating || knowledgeBases.length === 0}
                                        className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                                            knowledgeEnabled ? 'bg-violet-600' : 'bg-gray-300 dark:bg-[#27272a]'
                                        } disabled:opacity-50 disabled:cursor-not-allowed`}
                                        title={knowledgeBases.length === 0 ? '请先创建知识库' : (knowledgeEnabled ? '禁用知识库' : '启用知识库')}
                                    >
                                        <span
                                            className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                                                knowledgeEnabled ? 'translate-x-6' : 'translate-x-1'
                                            }`}
                                        />
                                    </button>
                                </div>
                                <select
                                    value={modelId}
                                    onChange={handleModelChange}
                                    className="bg-gray-100 dark:bg-[#1f1f23] border border-gray-300 dark:border-[#27272a] rounded-lg px-3 py-1.5 text-sm text-gray-900 dark:text-white focus:outline-none focus:border-violet-500"
                                >
                                    <option value="">选择模型...</option>
                                    <optgroup label="低显存模型">
                                        {MODEL_LIST.filter(m => m.category === 'low').map(m => (
                                            <option key={m.id} value={m.id}>{m.name}</option>
                                        ))}
                                    </optgroup>
                                    <optgroup label="高显存模型">
                                        {MODEL_LIST.filter(m => m.category === 'high').map(m => (
                                            <option key={m.id} value={m.id}>{m.name}</option>
                                        ))}
                                    </optgroup>
                                </select>
                                <PrimaryButton
                                    onClick={() => modelId && loadModel(modelId)}
                                    disabled={loading}
                                    loading={loading}
                                    engine={engine}
                                />
                            </div>
                        </div>

                        {/* 进度条 */}
                        {loading && (
                            <div className="bg-white dark:bg-[#0a0a0a] border-b border-gray-200 dark:border-[#27272a] transition-colors duration-300">
                                <div className="flex justify-between text-xs text-gray-500 dark:text-zinc-400 px-6 py-2">
                                    <span>{progressText}</span>
                                    <span>{progress}%</span>
                                </div>
                                <div className="h-1 bg-gray-200 dark:bg-[#27272a]">
                                    <div
                                        className="h-full bg-gradient-to-r from-violet-600 to-indigo-600 transition-all duration-300"
                                        style={{ width: `${progress}%` }}
                                    />
                                </div>
                            </div>
                        )}

                        {/* 聊天区域 */}
                        <div className="flex-1 overflow-y-auto custom-scrollbar p-6 space-y-6 bg-white dark:bg-[#0a0a0a] transition-colors duration-300">
                            {silentLoading ? (
                                <div className="flex flex-col items-center justify-center h-full min-h-[400px]">
                                    <div className="relative">
                                        {/* 脉冲动画圆环 */}
                                        <div className="w-20 h-20 rounded-full border-4 border-violet-200 dark:border-violet-800"></div>
                                        <div className="absolute top-0 left-0 w-20 h-20 rounded-full border-4 border-violet-500 border-t-transparent animate-spin"></div>
                                        {/* 中间 Logo */}
                                        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-12 h-12 rounded-xl overflow-hidden shadow-lg shadow-rose-500/30 border-2 border-rose-500/50">
                                            <img src="Ming.jpg" alt="Ming" className="w-full h-full object-cover" />
                                        </div>
                                    </div>
                                    <p className="mt-6 text-lg font-medium text-gray-700 dark:text-zinc-300">正在初始化模型</p>
                                    <p className="mt-2 text-sm text-gray-500 dark:text-zinc-500">请稍候，马上就好...</p>
                                    <div className="mt-4 flex gap-1">
                                        <span className="w-2 h-2 bg-violet-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></span>
                                        <span className="w-2 h-2 bg-violet-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></span>
                                        <span className="w-2 h-2 bg-violet-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></span>
                                    </div>
                                </div>
                            ) : messages.length === 0 ? (
                                <div className="text-center text-gray-500 dark:text-zinc-500 py-20">
                                    <div className="w-16 h-16 mx-auto mb-4 rounded-2xl overflow-hidden shadow-lg shadow-rose-500/30 border-2 border-rose-500/50">
                                        <img src="Ming.jpg" alt="Ming" className="w-full h-full object-cover" />
                                    </div>
                                    <p className="text-gray-600 dark:text-zinc-400 mb-2">与 AI 开始对话</p>
                                    <p className="text-sm text-gray-500 dark:text-zinc-500">请在上方选择模型并加载</p>
                                </div>
                            ) : (
                                messages.map((msg, i) => (
                                    <MessageBubble
                                        key={i}
                                        role={msg.role}
                                        content={msg.content || (isGenerating && msg.role === 'assistant' ? (
                                            <div className="flex gap-1 py-1">
                                                <span className="typing-dot w-1.5 h-1.5 bg-zinc-400 rounded-full"></span>
                                                <span className="typing-dot w-1.5 h-1.5 bg-zinc-400 rounded-full"></span>
                                                <span className="typing-dot w-1.5 h-1.5 bg-zinc-400 rounded-full"></span>
                                            </div>
                                        ) : '')}
                                        timestamp={msg.timestamp}
                                        retrievedChunks={msg.retrievedChunks || []}
                                    />
                                ))
                            )}
                            <div ref={chatEndRef} />
                        </div>

                        {/* 输入区域 */}
                        <div className="p-4 bg-white dark:bg-[#0a0a0a] border-t border-gray-200 dark:border-[#27272a] transition-colors duration-300">
                            {modelId && !engine && !loading && (
                                <div className="mb-2 text-center text-xs text-amber-400">
                                    该模型未缓存，请点击上方按钮加载模型
                                </div>
                            )}
                            <div className="max-w-3xl mx-auto flex gap-3">
                                <input
                                    ref={inputRef}
                                    type="text"
                                    value={input}
                                    onChange={(e) => setInput(e.target.value)}
                                    onKeyDown={handleKeyDown}
                                    placeholder={loading ? '模型加载中...' : (!engine ? '请先加载模型' : '输入消息...')}
                                    disabled={loading || !engine || isGenerating}
                                    className="flex-1 bg-gray-100 dark:bg-[#1f1f23] border border-gray-300 dark:border-[#27272a] rounded-full px-5 py-3 text-sm text-gray-900 dark:text-white placeholder-gray-400 dark:placeholder-zinc-500 focus:outline-none focus:border-violet-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-300"
                                />
                                {isGenerating ? (
                                    <StopButton onClick={abortGeneration} />
                                ) : (
                                    <SendButton onClick={sendMessage} disabled={loading || !engine || isGenerating || !input.trim()} />
                                )}
                            </div>
                        </div>
                    </div>
                </div>
                </>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <MessageProvider>
                <ConfirmProvider>
                    <App />
                </ConfirmProvider>
            </MessageProvider>
        );
    </script>
</body>

</html>